<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Tuesday: &lt;tue/mat.hpp&gt;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Tuesday
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">&lt;tue/mat.hpp&gt;</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <code>mat</code> class template and its associated functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:classtue_1_1mat"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat&lt; T, C, R &gt;</a></td></tr>
<tr class="memdesc:classtue_1_1mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">A column-major matrix.  <a href="group__mat__hpp.html#classtue_1_1mat">More...</a><br /></td></tr>
<tr class="separator:classtue_1_1mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga60a6d444af56a15e792baf8b579e8d92"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga60a6d444af56a15e792baf8b579e8d92"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga60a6d444af56a15e792baf8b579e8d92">tue::mat2x2</a> = mat&lt; T, 2, 2 &gt;</td></tr>
<tr class="memdesc:ga60a6d444af56a15e792baf8b579e8d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2x2 matrix.  <a href="group__mat__hpp.html#ga60a6d444af56a15e792baf8b579e8d92">More...</a><br /></td></tr>
<tr class="separator:ga60a6d444af56a15e792baf8b579e8d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42b45ba8b8b912c26571ae04cf52c066"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga42b45ba8b8b912c26571ae04cf52c066"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga42b45ba8b8b912c26571ae04cf52c066">tue::mat2x3</a> = mat&lt; T, 2, 3 &gt;</td></tr>
<tr class="memdesc:ga42b45ba8b8b912c26571ae04cf52c066"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2x3 matrix.  <a href="group__mat__hpp.html#ga42b45ba8b8b912c26571ae04cf52c066">More...</a><br /></td></tr>
<tr class="separator:ga42b45ba8b8b912c26571ae04cf52c066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga233a373c492e5e9a9d05958b6faf2b29"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga233a373c492e5e9a9d05958b6faf2b29"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga233a373c492e5e9a9d05958b6faf2b29">tue::mat2x4</a> = mat&lt; T, 2, 4 &gt;</td></tr>
<tr class="memdesc:ga233a373c492e5e9a9d05958b6faf2b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2x4 matrix.  <a href="group__mat__hpp.html#ga233a373c492e5e9a9d05958b6faf2b29">More...</a><br /></td></tr>
<tr class="separator:ga233a373c492e5e9a9d05958b6faf2b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1cc493760cbf7f6a39d7b7c3bab406d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa1cc493760cbf7f6a39d7b7c3bab406d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gaa1cc493760cbf7f6a39d7b7c3bab406d">tue::mat3x2</a> = mat&lt; T, 3, 2 &gt;</td></tr>
<tr class="memdesc:gaa1cc493760cbf7f6a39d7b7c3bab406d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3x2 matrix.  <a href="group__mat__hpp.html#gaa1cc493760cbf7f6a39d7b7c3bab406d">More...</a><br /></td></tr>
<tr class="separator:gaa1cc493760cbf7f6a39d7b7c3bab406d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1af37cd6fd67c0bda4030197ce6b985c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1af37cd6fd67c0bda4030197ce6b985c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga1af37cd6fd67c0bda4030197ce6b985c">tue::mat3x3</a> = mat&lt; T, 3, 3 &gt;</td></tr>
<tr class="memdesc:ga1af37cd6fd67c0bda4030197ce6b985c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3x3 matrix.  <a href="group__mat__hpp.html#ga1af37cd6fd67c0bda4030197ce6b985c">More...</a><br /></td></tr>
<tr class="separator:ga1af37cd6fd67c0bda4030197ce6b985c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3233f950e6bac0b09ec2fa6e567a3685"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3233f950e6bac0b09ec2fa6e567a3685"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga3233f950e6bac0b09ec2fa6e567a3685">tue::mat3x4</a> = mat&lt; T, 3, 4 &gt;</td></tr>
<tr class="memdesc:ga3233f950e6bac0b09ec2fa6e567a3685"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3x4 matrix.  <a href="group__mat__hpp.html#ga3233f950e6bac0b09ec2fa6e567a3685">More...</a><br /></td></tr>
<tr class="separator:ga3233f950e6bac0b09ec2fa6e567a3685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e32f544eff5596e4a058422a923bc55"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6e32f544eff5596e4a058422a923bc55"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga6e32f544eff5596e4a058422a923bc55">tue::mat4x2</a> = mat&lt; T, 4, 2 &gt;</td></tr>
<tr class="memdesc:ga6e32f544eff5596e4a058422a923bc55"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 4x2 matrix.  <a href="group__mat__hpp.html#ga6e32f544eff5596e4a058422a923bc55">More...</a><br /></td></tr>
<tr class="separator:ga6e32f544eff5596e4a058422a923bc55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadda0fb2a6ad36b2893014611c9b73e30"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gadda0fb2a6ad36b2893014611c9b73e30"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gadda0fb2a6ad36b2893014611c9b73e30">tue::mat4x3</a> = mat&lt; T, 4, 3 &gt;</td></tr>
<tr class="memdesc:gadda0fb2a6ad36b2893014611c9b73e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 4x3 matrix.  <a href="group__mat__hpp.html#gadda0fb2a6ad36b2893014611c9b73e30">More...</a><br /></td></tr>
<tr class="separator:gadda0fb2a6ad36b2893014611c9b73e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0df1ce73b487ecda5aa0000c8e34eaa8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0df1ce73b487ecda5aa0000c8e34eaa8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga0df1ce73b487ecda5aa0000c8e34eaa8">tue::mat4x4</a> = mat&lt; T, 4, 4 &gt;</td></tr>
<tr class="memdesc:ga0df1ce73b487ecda5aa0000c8e34eaa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 4x4 matrix.  <a href="group__mat__hpp.html#ga0df1ce73b487ecda5aa0000c8e34eaa8">More...</a><br /></td></tr>
<tr class="separator:ga0df1ce73b487ecda5aa0000c8e34eaa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80e533a486177cd40ec5a94bdc361bd1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga80e533a486177cd40ec5a94bdc361bd1">tue::fmat2x2</a> = mat2x2&lt; float &gt;</td></tr>
<tr class="memdesc:ga80e533a486177cd40ec5a94bdc361bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2x2 matrix with <code>float</code> components.  <a href="group__mat__hpp.html#ga80e533a486177cd40ec5a94bdc361bd1">More...</a><br /></td></tr>
<tr class="separator:ga80e533a486177cd40ec5a94bdc361bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab20dd4c9f6458bdbb4f09c55b35c9e9c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gab20dd4c9f6458bdbb4f09c55b35c9e9c">tue::fmat2x3</a> = mat2x3&lt; float &gt;</td></tr>
<tr class="memdesc:gab20dd4c9f6458bdbb4f09c55b35c9e9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2x3 matrix with <code>float</code> components.  <a href="group__mat__hpp.html#gab20dd4c9f6458bdbb4f09c55b35c9e9c">More...</a><br /></td></tr>
<tr class="separator:gab20dd4c9f6458bdbb4f09c55b35c9e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d4d37b9fa3a637d223aaa851cb4aef8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga7d4d37b9fa3a637d223aaa851cb4aef8">tue::fmat2x4</a> = mat2x4&lt; float &gt;</td></tr>
<tr class="memdesc:ga7d4d37b9fa3a637d223aaa851cb4aef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2x4 matrix with <code>float</code> components.  <a href="group__mat__hpp.html#ga7d4d37b9fa3a637d223aaa851cb4aef8">More...</a><br /></td></tr>
<tr class="separator:ga7d4d37b9fa3a637d223aaa851cb4aef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf7fa6a602e6074e460b6e79276e31de"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gabf7fa6a602e6074e460b6e79276e31de">tue::fmat3x2</a> = mat3x2&lt; float &gt;</td></tr>
<tr class="memdesc:gabf7fa6a602e6074e460b6e79276e31de"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3x2 matrix with <code>float</code> components.  <a href="group__mat__hpp.html#gabf7fa6a602e6074e460b6e79276e31de">More...</a><br /></td></tr>
<tr class="separator:gabf7fa6a602e6074e460b6e79276e31de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga998dbb4ce3e1871515f28ddd748e5459"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga998dbb4ce3e1871515f28ddd748e5459">tue::fmat3x3</a> = mat3x3&lt; float &gt;</td></tr>
<tr class="memdesc:ga998dbb4ce3e1871515f28ddd748e5459"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3x3 matrix with <code>float</code> components.  <a href="group__mat__hpp.html#ga998dbb4ce3e1871515f28ddd748e5459">More...</a><br /></td></tr>
<tr class="separator:ga998dbb4ce3e1871515f28ddd748e5459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c3d86c133031648485e9936e22602d8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga1c3d86c133031648485e9936e22602d8">tue::fmat3x4</a> = mat3x4&lt; float &gt;</td></tr>
<tr class="memdesc:ga1c3d86c133031648485e9936e22602d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3x4 matrix with <code>float</code> components.  <a href="group__mat__hpp.html#ga1c3d86c133031648485e9936e22602d8">More...</a><br /></td></tr>
<tr class="separator:ga1c3d86c133031648485e9936e22602d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9971dc09a5b5872b7c09fec994917b5c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga9971dc09a5b5872b7c09fec994917b5c">tue::fmat4x2</a> = mat4x2&lt; float &gt;</td></tr>
<tr class="memdesc:ga9971dc09a5b5872b7c09fec994917b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 4x2 matrix with <code>float</code> components.  <a href="group__mat__hpp.html#ga9971dc09a5b5872b7c09fec994917b5c">More...</a><br /></td></tr>
<tr class="separator:ga9971dc09a5b5872b7c09fec994917b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga840a930e35b20bac78811420befa9826"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga840a930e35b20bac78811420befa9826">tue::fmat4x3</a> = mat4x3&lt; float &gt;</td></tr>
<tr class="memdesc:ga840a930e35b20bac78811420befa9826"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 4x3 matrix with <code>float</code> components.  <a href="group__mat__hpp.html#ga840a930e35b20bac78811420befa9826">More...</a><br /></td></tr>
<tr class="separator:ga840a930e35b20bac78811420befa9826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae02ecf769302be1069d43a9980c6daa6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gae02ecf769302be1069d43a9980c6daa6">tue::fmat4x4</a> = mat4x4&lt; float &gt;</td></tr>
<tr class="memdesc:gae02ecf769302be1069d43a9980c6daa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 4x4 matrix with <code>float</code> components.  <a href="group__mat__hpp.html#gae02ecf769302be1069d43a9980c6daa6">More...</a><br /></td></tr>
<tr class="separator:gae02ecf769302be1069d43a9980c6daa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b7ecdb3d7b53b4f208886d12d8e123a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga5b7ecdb3d7b53b4f208886d12d8e123a">tue::dmat2x2</a> = mat2x2&lt; double &gt;</td></tr>
<tr class="memdesc:ga5b7ecdb3d7b53b4f208886d12d8e123a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2x2 matrix with <code>double</code> components.  <a href="group__mat__hpp.html#ga5b7ecdb3d7b53b4f208886d12d8e123a">More...</a><br /></td></tr>
<tr class="separator:ga5b7ecdb3d7b53b4f208886d12d8e123a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad98f27e588a223a5f3bd2bf90d59871a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gad98f27e588a223a5f3bd2bf90d59871a">tue::dmat2x3</a> = mat2x3&lt; double &gt;</td></tr>
<tr class="memdesc:gad98f27e588a223a5f3bd2bf90d59871a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2x3 matrix with <code>double</code> components.  <a href="group__mat__hpp.html#gad98f27e588a223a5f3bd2bf90d59871a">More...</a><br /></td></tr>
<tr class="separator:gad98f27e588a223a5f3bd2bf90d59871a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga846ad763f3e8078e7e0260596357e527"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga846ad763f3e8078e7e0260596357e527">tue::dmat2x4</a> = mat2x4&lt; double &gt;</td></tr>
<tr class="memdesc:ga846ad763f3e8078e7e0260596357e527"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2x4 matrix with <code>double</code> components.  <a href="group__mat__hpp.html#ga846ad763f3e8078e7e0260596357e527">More...</a><br /></td></tr>
<tr class="separator:ga846ad763f3e8078e7e0260596357e527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4705444994047a4f9d13fddb54213750"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga4705444994047a4f9d13fddb54213750">tue::dmat3x2</a> = mat3x2&lt; double &gt;</td></tr>
<tr class="memdesc:ga4705444994047a4f9d13fddb54213750"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3x2 matrix with <code>double</code> components.  <a href="group__mat__hpp.html#ga4705444994047a4f9d13fddb54213750">More...</a><br /></td></tr>
<tr class="separator:ga4705444994047a4f9d13fddb54213750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafba906f634cf63e802ffddfb2d3bcd0a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gafba906f634cf63e802ffddfb2d3bcd0a">tue::dmat3x3</a> = mat3x3&lt; double &gt;</td></tr>
<tr class="memdesc:gafba906f634cf63e802ffddfb2d3bcd0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3x3 matrix with <code>double</code> components.  <a href="group__mat__hpp.html#gafba906f634cf63e802ffddfb2d3bcd0a">More...</a><br /></td></tr>
<tr class="separator:gafba906f634cf63e802ffddfb2d3bcd0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbcb9f2be10e2ef2a9b118fb5aa7a079"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gacbcb9f2be10e2ef2a9b118fb5aa7a079">tue::dmat3x4</a> = mat3x4&lt; double &gt;</td></tr>
<tr class="memdesc:gacbcb9f2be10e2ef2a9b118fb5aa7a079"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3x4 matrix with <code>double</code> components.  <a href="group__mat__hpp.html#gacbcb9f2be10e2ef2a9b118fb5aa7a079">More...</a><br /></td></tr>
<tr class="separator:gacbcb9f2be10e2ef2a9b118fb5aa7a079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00ae9b428d4457cd2e0655b7405e81f0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga00ae9b428d4457cd2e0655b7405e81f0">tue::dmat4x2</a> = mat4x2&lt; double &gt;</td></tr>
<tr class="memdesc:ga00ae9b428d4457cd2e0655b7405e81f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 4x2 matrix with <code>double</code> components.  <a href="group__mat__hpp.html#ga00ae9b428d4457cd2e0655b7405e81f0">More...</a><br /></td></tr>
<tr class="separator:ga00ae9b428d4457cd2e0655b7405e81f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c25992cc3db7e4e7b2e5689bbf54990"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga8c25992cc3db7e4e7b2e5689bbf54990">tue::dmat4x3</a> = mat4x3&lt; double &gt;</td></tr>
<tr class="memdesc:ga8c25992cc3db7e4e7b2e5689bbf54990"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 4x3 matrix with <code>double</code> components.  <a href="group__mat__hpp.html#ga8c25992cc3db7e4e7b2e5689bbf54990">More...</a><br /></td></tr>
<tr class="separator:ga8c25992cc3db7e4e7b2e5689bbf54990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69a3b00df771a6da9d5eeaa9037c6383"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga69a3b00df771a6da9d5eeaa9037c6383">tue::dmat4x4</a> = mat4x4&lt; double &gt;</td></tr>
<tr class="memdesc:ga69a3b00df771a6da9d5eeaa9037c6383"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 4x4 matrix with <code>double</code> components.  <a href="group__mat__hpp.html#ga69a3b00df771a6da9d5eeaa9037c6383">More...</a><br /></td></tr>
<tr class="separator:ga69a3b00df771a6da9d5eeaa9037c6383"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga105c13000f760427fef886850cb232fe"><td class="memTemplParams" colspan="2">template&lt;typename T , int C, int R&gt; </td></tr>
<tr class="memitem:ga105c13000f760427fef886850cb232fe"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(+std::declval&lt; T &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga105c13000f760427fef886850cb232fe">tue::operator+</a> (const mat&lt; T, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:ga105c13000f760427fef886850cb232fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the unary plus of each component of <code>m</code>.  <a href="group__mat__hpp.html#ga105c13000f760427fef886850cb232fe">More...</a><br /></td></tr>
<tr class="separator:ga105c13000f760427fef886850cb232fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28ee4aaf5707d2de51eff8bdc65e99ca"><td class="memTemplParams" colspan="2">template&lt;typename T , int C, int R&gt; </td></tr>
<tr class="memitem:ga28ee4aaf5707d2de51eff8bdc65e99ca"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(-std::declval&lt; T &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga28ee4aaf5707d2de51eff8bdc65e99ca">tue::operator-</a> (const mat&lt; T, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:ga28ee4aaf5707d2de51eff8bdc65e99ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the unary minus of each component of <code>m</code>.  <a href="group__mat__hpp.html#ga28ee4aaf5707d2de51eff8bdc65e99ca">More...</a><br /></td></tr>
<tr class="separator:ga28ee4aaf5707d2de51eff8bdc65e99ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa07d7dace8c23fdb460f29e46f705077"><td class="memTemplParams" colspan="2">template&lt;typename T , int C, int R&gt; </td></tr>
<tr class="memitem:gaa07d7dace8c23fdb460f29e46f705077"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(~std::declval&lt; T &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gaa07d7dace8c23fdb460f29e46f705077">tue::operator~</a> (const mat&lt; T, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:gaa07d7dace8c23fdb460f29e46f705077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bitwise NOT of each component of <code>m</code>.  <a href="group__mat__hpp.html#gaa07d7dace8c23fdb460f29e46f705077">More...</a><br /></td></tr>
<tr class="separator:gaa07d7dace8c23fdb460f29e46f705077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1644a674687d3555bd68eb11e001f58"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:gab1644a674687d3555bd68eb11e001f58"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; is_vec_component&lt; T &gt;::value, mat&lt; decltype(std::declval&lt; T &gt;)+std::declval&lt; U &gt;)), C, R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gab1644a674687d3555bd68eb11e001f58">tue::operator+</a> (const T &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:gab1644a674687d3555bd68eb11e001f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sums of <code>lhs</code> and each component of <code>rhs</code>.  <a href="group__mat__hpp.html#gab1644a674687d3555bd68eb11e001f58">More...</a><br /></td></tr>
<tr class="separator:gab1644a674687d3555bd68eb11e001f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21e81d717d2e7a1007b6070472e1e824"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga21e81d717d2e7a1007b6070472e1e824"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; is_vec_component&lt; U &gt;::value, mat&lt; decltype(std::declval&lt; T &gt;)+std::declval&lt; U &gt;)), C, R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga21e81d717d2e7a1007b6070472e1e824">tue::operator+</a> (const mat&lt; T, C, R &gt; &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga21e81d717d2e7a1007b6070472e1e824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sums of each component of <code>lhs</code> and <code>rhs</code>.  <a href="group__mat__hpp.html#ga21e81d717d2e7a1007b6070472e1e824">More...</a><br /></td></tr>
<tr class="separator:ga21e81d717d2e7a1007b6070472e1e824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga797da95865c09dbb33905d289aac7d83"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga797da95865c09dbb33905d289aac7d83"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(std::declval&lt; T &gt;)+std::declval&lt; U &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga797da95865c09dbb33905d289aac7d83">tue::operator+</a> (const mat&lt; T, C, R &gt; &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga797da95865c09dbb33905d289aac7d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sums of each component of <code>lhs</code> and each corresponding component of <code>rhs</code>.  <a href="group__mat__hpp.html#ga797da95865c09dbb33905d289aac7d83">More...</a><br /></td></tr>
<tr class="separator:ga797da95865c09dbb33905d289aac7d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcbd8369f10ddbafca8c4644227b7c3b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:gafcbd8369f10ddbafca8c4644227b7c3b"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; is_vec_component&lt; T &gt;::value, mat&lt; decltype(std::declval&lt; T &gt;)-std::declval&lt; U &gt;)), C, R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gafcbd8369f10ddbafca8c4644227b7c3b">tue::operator-</a> (const T &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:gafcbd8369f10ddbafca8c4644227b7c3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the differences between <code>lhs</code> and each component of <code>rhs</code>.  <a href="group__mat__hpp.html#gafcbd8369f10ddbafca8c4644227b7c3b">More...</a><br /></td></tr>
<tr class="separator:gafcbd8369f10ddbafca8c4644227b7c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85e116ffaf8bbf4eb9cbfd6c107ea986"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga85e116ffaf8bbf4eb9cbfd6c107ea986"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; is_vec_component&lt; U &gt;::value, mat&lt; decltype(std::declval&lt; T &gt;)-std::declval&lt; U &gt;)), C, R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga85e116ffaf8bbf4eb9cbfd6c107ea986">tue::operator-</a> (const mat&lt; T, C, R &gt; &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga85e116ffaf8bbf4eb9cbfd6c107ea986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the differences between each component of <code>lhs</code> and <code>rhs</code>.  <a href="group__mat__hpp.html#ga85e116ffaf8bbf4eb9cbfd6c107ea986">More...</a><br /></td></tr>
<tr class="separator:ga85e116ffaf8bbf4eb9cbfd6c107ea986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2c8e4f0603a59fa3d6e423ef87b4c2d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:gaa2c8e4f0603a59fa3d6e423ef87b4c2d"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(std::declval&lt; T &gt;)-std::declval&lt; U &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gaa2c8e4f0603a59fa3d6e423ef87b4c2d">tue::operator-</a> (const mat&lt; T, C, R &gt; &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:gaa2c8e4f0603a59fa3d6e423ef87b4c2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the differences between each component of <code>lhs</code> and each corresponding component of <code>rhs</code>.  <a href="group__mat__hpp.html#gaa2c8e4f0603a59fa3d6e423ef87b4c2d">More...</a><br /></td></tr>
<tr class="separator:gaa2c8e4f0603a59fa3d6e423ef87b4c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade54eaf0cc1490820a12b8eaf9a3c265"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:gade54eaf0cc1490820a12b8eaf9a3c265"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; is_vec_component&lt; T &gt;::value, mat&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;)), C, R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gade54eaf0cc1490820a12b8eaf9a3c265">tue::operator*</a> (const T &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:gade54eaf0cc1490820a12b8eaf9a3c265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the products of <code>lhs</code> and each component of <code>rhs</code>.  <a href="group__mat__hpp.html#gade54eaf0cc1490820a12b8eaf9a3c265">More...</a><br /></td></tr>
<tr class="separator:gade54eaf0cc1490820a12b8eaf9a3c265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga724681a2c9560ba64ec32cdfdfdf54f3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga724681a2c9560ba64ec32cdfdfdf54f3"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; is_vec_component&lt; U &gt;::value, mat&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;)), C, R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga724681a2c9560ba64ec32cdfdfdf54f3">tue::operator*</a> (const mat&lt; T, C, R &gt; &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga724681a2c9560ba64ec32cdfdfdf54f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the products of each component of <code>lhs</code> and <code>rhs</code>.  <a href="group__mat__hpp.html#ga724681a2c9560ba64ec32cdfdfdf54f3">More...</a><br /></td></tr>
<tr class="separator:ga724681a2c9560ba64ec32cdfdfdf54f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad34bf6bf898ec2a9876d2b2cee9f535f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:gad34bf6bf898ec2a9876d2b2cee9f535f"><td class="memTemplItemLeft" align="right" valign="top">constexpr vec&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;)), C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gad34bf6bf898ec2a9876d2b2cee9f535f">tue::operator*</a> (const vec&lt; T, R &gt; &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:gad34bf6bf898ec2a9876d2b2cee9f535f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the matrix product of <code>lhs</code> and <code>rhs</code>.  <a href="group__mat__hpp.html#gad34bf6bf898ec2a9876d2b2cee9f535f">More...</a><br /></td></tr>
<tr class="separator:gad34bf6bf898ec2a9876d2b2cee9f535f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb7b725c10f654beaf6ac1b4c2e5e739"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:gaeb7b725c10f654beaf6ac1b4c2e5e739"><td class="memTemplItemLeft" align="right" valign="top">constexpr vec&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;)), R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gaeb7b725c10f654beaf6ac1b4c2e5e739">tue::operator*</a> (const mat&lt; T, C, R &gt; &amp;lhs, const vec&lt; U, C &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:gaeb7b725c10f654beaf6ac1b4c2e5e739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the matrix product of <code>lhs</code> and <code>rhs</code>.  <a href="group__mat__hpp.html#gaeb7b725c10f654beaf6ac1b4c2e5e739">More...</a><br /></td></tr>
<tr class="separator:gaeb7b725c10f654beaf6ac1b4c2e5e739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga496433423f8744e525f4aa9a6dadb329"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int N, int R&gt; </td></tr>
<tr class="memitem:ga496433423f8744e525f4aa9a6dadb329"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga496433423f8744e525f4aa9a6dadb329">tue::operator*</a> (const mat&lt; T, N, R &gt; &amp;lhs, const mat&lt; U, C, N &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga496433423f8744e525f4aa9a6dadb329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the matrix product of <code>lhs</code> and <code>rhs</code>.  <a href="group__mat__hpp.html#ga496433423f8744e525f4aa9a6dadb329">More...</a><br /></td></tr>
<tr class="separator:ga496433423f8744e525f4aa9a6dadb329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb089f96caec4311a221ab76729f0e9e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:gaeb089f96caec4311a221ab76729f0e9e"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; is_vec_component&lt; T &gt;::value, mat&lt; decltype(std::declval&lt; T &gt;)/std::declval&lt; U &gt;)), C, R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gaeb089f96caec4311a221ab76729f0e9e">tue::operator/</a> (const T &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:gaeb089f96caec4311a221ab76729f0e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the quotients of <code>lhs</code> over each component of <code>rhs</code>.  <a href="group__mat__hpp.html#gaeb089f96caec4311a221ab76729f0e9e">More...</a><br /></td></tr>
<tr class="separator:gaeb089f96caec4311a221ab76729f0e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62844dd3759063535fb62dd2c2fb11da"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga62844dd3759063535fb62dd2c2fb11da"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; is_vec_component&lt; U &gt;::value, mat&lt; decltype(std::declval&lt; T &gt;)/std::declval&lt; U &gt;)), C, R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga62844dd3759063535fb62dd2c2fb11da">tue::operator/</a> (const mat&lt; T, C, R &gt; &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga62844dd3759063535fb62dd2c2fb11da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the quotients of each component of <code>lhs</code> over <code>rhs</code>.  <a href="group__mat__hpp.html#ga62844dd3759063535fb62dd2c2fb11da">More...</a><br /></td></tr>
<tr class="separator:ga62844dd3759063535fb62dd2c2fb11da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ca0edc97d146e5d7553edc224ae6b10"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga8ca0edc97d146e5d7553edc224ae6b10"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(std::declval&lt; T &gt;)/std::declval&lt; U &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga8ca0edc97d146e5d7553edc224ae6b10">tue::operator/</a> (const mat&lt; T, C, R &gt; &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga8ca0edc97d146e5d7553edc224ae6b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the quotients of each component of <code>lhs</code> over each corresponding component of <code>rhs</code>.  <a href="group__mat__hpp.html#ga8ca0edc97d146e5d7553edc224ae6b10">More...</a><br /></td></tr>
<tr class="separator:ga8ca0edc97d146e5d7553edc224ae6b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5db23838849e6df1e9cb2e0372581ca1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga5db23838849e6df1e9cb2e0372581ca1"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; is_vec_component&lt; T &gt;::value, mat&lt; decltype(std::declval&lt; T &gt;)%std::declval&lt; U &gt;)), C, R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga5db23838849e6df1e9cb2e0372581ca1">tue::operator%</a> (const T &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga5db23838849e6df1e9cb2e0372581ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the modulos of <code>lhs</code> over each component of <code>rhs</code>.  <a href="group__mat__hpp.html#ga5db23838849e6df1e9cb2e0372581ca1">More...</a><br /></td></tr>
<tr class="separator:ga5db23838849e6df1e9cb2e0372581ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb8ddd66598aaea819264addb9441c80"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:gaeb8ddd66598aaea819264addb9441c80"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; is_vec_component&lt; U &gt;::value, mat&lt; decltype(std::declval&lt; T &gt;)%std::declval&lt; U &gt;)), C, R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gaeb8ddd66598aaea819264addb9441c80">tue::operator%</a> (const mat&lt; T, C, R &gt; &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="memdesc:gaeb8ddd66598aaea819264addb9441c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the modulos of each component of <code>lhs</code> over <code>rhs</code>.  <a href="group__mat__hpp.html#gaeb8ddd66598aaea819264addb9441c80">More...</a><br /></td></tr>
<tr class="separator:gaeb8ddd66598aaea819264addb9441c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga532739222ec07d79696eba0d312944c3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga532739222ec07d79696eba0d312944c3"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(std::declval&lt; T &gt;)%std::declval&lt; U &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga532739222ec07d79696eba0d312944c3">tue::operator%</a> (const mat&lt; T, C, R &gt; &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga532739222ec07d79696eba0d312944c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the modulos of each component of <code>lhs</code> over each corresponding component of <code>rhs</code>.  <a href="group__mat__hpp.html#ga532739222ec07d79696eba0d312944c3">More...</a><br /></td></tr>
<tr class="separator:ga532739222ec07d79696eba0d312944c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cff4234c46b11c2b0c11e50e9358f35"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga7cff4234c46b11c2b0c11e50e9358f35"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; is_vec_component&lt; T &gt;::value, mat&lt; decltype(std::declval&lt; T &gt;)&amp;std::declval&lt; U &gt;)), C, R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga7cff4234c46b11c2b0c11e50e9358f35">tue::operator&amp;</a> (const T &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga7cff4234c46b11c2b0c11e50e9358f35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bitwise AND of <code>lhs</code> and each component of <code>rhs</code>.  <a href="group__mat__hpp.html#ga7cff4234c46b11c2b0c11e50e9358f35">More...</a><br /></td></tr>
<tr class="separator:ga7cff4234c46b11c2b0c11e50e9358f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga933c909f74b8c6f26630709cc5ee07ca"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga933c909f74b8c6f26630709cc5ee07ca"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; is_vec_component&lt; U &gt;::value, mat&lt; decltype(std::declval&lt; T &gt;)&amp;std::declval&lt; U &gt;)), C, R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga933c909f74b8c6f26630709cc5ee07ca">tue::operator&amp;</a> (const mat&lt; T, C, R &gt; &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga933c909f74b8c6f26630709cc5ee07ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bitwise AND of each component of <code>lhs</code> and <code>rhs</code>.  <a href="group__mat__hpp.html#ga933c909f74b8c6f26630709cc5ee07ca">More...</a><br /></td></tr>
<tr class="separator:ga933c909f74b8c6f26630709cc5ee07ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga076647c106e6fd9cb38ddb0e4d8611f6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga076647c106e6fd9cb38ddb0e4d8611f6"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(std::declval&lt; T &gt;)&amp;std::declval&lt; U &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga076647c106e6fd9cb38ddb0e4d8611f6">tue::operator&amp;</a> (const mat&lt; T, C, R &gt; &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga076647c106e6fd9cb38ddb0e4d8611f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bitwise AND of each component of <code>lhs</code> and each corresponding component of <code>rhs</code>.  <a href="group__mat__hpp.html#ga076647c106e6fd9cb38ddb0e4d8611f6">More...</a><br /></td></tr>
<tr class="separator:ga076647c106e6fd9cb38ddb0e4d8611f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga309489790323d76920d10fda7e18b0e1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga309489790323d76920d10fda7e18b0e1"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; is_vec_component&lt; T &gt;::value, mat&lt; decltype(std::declval&lt; T &gt;)|std::declval&lt; U &gt;)), C, R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga309489790323d76920d10fda7e18b0e1">tue::operator|</a> (const T &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga309489790323d76920d10fda7e18b0e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bitwise OR of <code>lhs</code> and each component of <code>rhs</code>.  <a href="group__mat__hpp.html#ga309489790323d76920d10fda7e18b0e1">More...</a><br /></td></tr>
<tr class="separator:ga309489790323d76920d10fda7e18b0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8105861f02626e2b42b752eb41a88079"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga8105861f02626e2b42b752eb41a88079"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; is_vec_component&lt; U &gt;::value, mat&lt; decltype(std::declval&lt; T &gt;)|std::declval&lt; U &gt;)), C, R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga8105861f02626e2b42b752eb41a88079">tue::operator|</a> (const mat&lt; T, C, R &gt; &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga8105861f02626e2b42b752eb41a88079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bitwise OR of each component of <code>lhs</code> and <code>rhs</code>.  <a href="group__mat__hpp.html#ga8105861f02626e2b42b752eb41a88079">More...</a><br /></td></tr>
<tr class="separator:ga8105861f02626e2b42b752eb41a88079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf55cd551d4ffb60b5acb1ab29d64e1f9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:gaf55cd551d4ffb60b5acb1ab29d64e1f9"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(std::declval&lt; T &gt;)|std::declval&lt; U &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gaf55cd551d4ffb60b5acb1ab29d64e1f9">tue::operator|</a> (const mat&lt; T, C, R &gt; &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:gaf55cd551d4ffb60b5acb1ab29d64e1f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bitwise OR of each component of <code>lhs</code> and each corresponding component of <code>rhs</code>.  <a href="group__mat__hpp.html#gaf55cd551d4ffb60b5acb1ab29d64e1f9">More...</a><br /></td></tr>
<tr class="separator:gaf55cd551d4ffb60b5acb1ab29d64e1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7347232415c843bfae601f78bf8f5c69"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga7347232415c843bfae601f78bf8f5c69"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; is_vec_component&lt; T &gt;::value, mat&lt; decltype(std::declval&lt; T &gt;)^std::declval&lt; U &gt;)), C, R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga7347232415c843bfae601f78bf8f5c69">tue::operator^</a> (const T &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga7347232415c843bfae601f78bf8f5c69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bitwise XOR of <code>lhs</code> and each component of <code>rhs</code>.  <a href="group__mat__hpp.html#ga7347232415c843bfae601f78bf8f5c69">More...</a><br /></td></tr>
<tr class="separator:ga7347232415c843bfae601f78bf8f5c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd01f1da79cbd83ba0c5143803f557ed"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:gacd01f1da79cbd83ba0c5143803f557ed"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; is_vec_component&lt; U &gt;::value, mat&lt; decltype(std::declval&lt; T &gt;)^std::declval&lt; U &gt;)), C, R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gacd01f1da79cbd83ba0c5143803f557ed">tue::operator^</a> (const mat&lt; T, C, R &gt; &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="memdesc:gacd01f1da79cbd83ba0c5143803f557ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bitwise XOR of each component of <code>lhs</code> and <code>rhs</code>.  <a href="group__mat__hpp.html#gacd01f1da79cbd83ba0c5143803f557ed">More...</a><br /></td></tr>
<tr class="separator:gacd01f1da79cbd83ba0c5143803f557ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade0afc7bcf6be71962fe78267235f178"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:gade0afc7bcf6be71962fe78267235f178"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(std::declval&lt; T &gt;)^std::declval&lt; U &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gade0afc7bcf6be71962fe78267235f178">tue::operator^</a> (const mat&lt; T, C, R &gt; &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:gade0afc7bcf6be71962fe78267235f178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bitwise XOR of each component of <code>lhs</code> and each corresponding component of <code>rhs</code>.  <a href="group__mat__hpp.html#gade0afc7bcf6be71962fe78267235f178">More...</a><br /></td></tr>
<tr class="separator:gade0afc7bcf6be71962fe78267235f178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0dce0b786973ab1605aa42a3c464377"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:gab0dce0b786973ab1605aa42a3c464377"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; is_vec_component&lt; T &gt;::value, mat&lt; decltype(std::declval&lt; T &gt;) shift_left std::declval&lt; U &gt;)), C, R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gab0dce0b786973ab1605aa42a3c464377">tue::operator&lt;&lt;</a> (const T &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:gab0dce0b786973ab1605aa42a3c464377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bitwise shifts left of <code>lhs</code> by each component of <code>rhs</code>.  <a href="group__mat__hpp.html#gab0dce0b786973ab1605aa42a3c464377">More...</a><br /></td></tr>
<tr class="separator:gab0dce0b786973ab1605aa42a3c464377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d8f05b8ba308c5e1f34ea44d3d514b1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga9d8f05b8ba308c5e1f34ea44d3d514b1"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; is_vec_component&lt; U &gt;::value, mat&lt; decltype(std::declval&lt; T &gt;) shift_left std::declval&lt; U &gt;)), C, R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga9d8f05b8ba308c5e1f34ea44d3d514b1">tue::operator&lt;&lt;</a> (const mat&lt; T, C, R &gt; &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga9d8f05b8ba308c5e1f34ea44d3d514b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bitwise shifts left of each component of <code>lhs</code> by <code>rhs</code>.  <a href="group__mat__hpp.html#ga9d8f05b8ba308c5e1f34ea44d3d514b1">More...</a><br /></td></tr>
<tr class="separator:ga9d8f05b8ba308c5e1f34ea44d3d514b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2549949c7896c79cf64712c4239fcda"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:gaa2549949c7896c79cf64712c4239fcda"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(std::declval&lt; T &gt;) shift_left std::declval&lt; U &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gaa2549949c7896c79cf64712c4239fcda">tue::operator&lt;&lt;</a> (const mat&lt; T, C, R &gt; &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:gaa2549949c7896c79cf64712c4239fcda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bitwise shifts left of each component of <code>lhs</code> by each corresponding component of <code>rhs</code>.  <a href="group__mat__hpp.html#gaa2549949c7896c79cf64712c4239fcda">More...</a><br /></td></tr>
<tr class="separator:gaa2549949c7896c79cf64712c4239fcda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga288dfc7575c317d12a4fbb83f20a8dff"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga288dfc7575c317d12a4fbb83f20a8dff"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; is_vec_component&lt; T &gt;::value, mat&lt; decltype(std::declval&lt; T &gt;) shift_right std::declval&lt; U &gt;)), C, R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga288dfc7575c317d12a4fbb83f20a8dff">tue::operator&gt;&gt;</a> (const T &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga288dfc7575c317d12a4fbb83f20a8dff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bitwise shifts right of <code>lhs</code> by each component of <code>rhs</code>.  <a href="group__mat__hpp.html#ga288dfc7575c317d12a4fbb83f20a8dff">More...</a><br /></td></tr>
<tr class="separator:ga288dfc7575c317d12a4fbb83f20a8dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac98cdf2ac121f5e26021c78b529b0a8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:gaac98cdf2ac121f5e26021c78b529b0a8"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; is_vec_component&lt; U &gt;::value, mat&lt; decltype(std::declval&lt; T &gt;) shift_right std::declval&lt; U &gt;)), C, R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gaac98cdf2ac121f5e26021c78b529b0a8">tue::operator&gt;&gt;</a> (const mat&lt; T, C, R &gt; &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="memdesc:gaac98cdf2ac121f5e26021c78b529b0a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bitwise shifts right of each component of <code>lhs</code> by <code>rhs</code>.  <a href="group__mat__hpp.html#gaac98cdf2ac121f5e26021c78b529b0a8">More...</a><br /></td></tr>
<tr class="separator:gaac98cdf2ac121f5e26021c78b529b0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1235dc009c8267d7eb34ea7aad5d652b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga1235dc009c8267d7eb34ea7aad5d652b"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(std::declval&lt; T &gt;) shift_right std::declval&lt; U &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga1235dc009c8267d7eb34ea7aad5d652b">tue::operator&gt;&gt;</a> (const mat&lt; T, C, R &gt; &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga1235dc009c8267d7eb34ea7aad5d652b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bitwise shifts right of each component of <code>lhs</code> by each corresponding component of <code>rhs</code>.  <a href="group__mat__hpp.html#ga1235dc009c8267d7eb34ea7aad5d652b">More...</a><br /></td></tr>
<tr class="separator:ga1235dc009c8267d7eb34ea7aad5d652b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31592c563ba596d54d4c5a0e74492da9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga31592c563ba596d54d4c5a0e74492da9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga31592c563ba596d54d4c5a0e74492da9">tue::operator==</a> (const mat&lt; T, C, R &gt; &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga31592c563ba596d54d4c5a0e74492da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not two <code>mat</code>'s compare equal.  <a href="group__mat__hpp.html#ga31592c563ba596d54d4c5a0e74492da9">More...</a><br /></td></tr>
<tr class="separator:ga31592c563ba596d54d4c5a0e74492da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab98bdf9495d8068da11fdd1d2bcf905b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:gab98bdf9495d8068da11fdd1d2bcf905b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gab98bdf9495d8068da11fdd1d2bcf905b">tue::operator!=</a> (const mat&lt; T, C, R &gt; &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:gab98bdf9495d8068da11fdd1d2bcf905b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not two <code>mat</code>'s compare not equal.  <a href="group__mat__hpp.html#gab98bdf9495d8068da11fdd1d2bcf905b">More...</a><br /></td></tr>
<tr class="separator:gab98bdf9495d8068da11fdd1d2bcf905b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f6ae28ba3a684c889d97135251a2a8d"><td class="memTemplParams" colspan="2">template&lt;typename T , int C, int R&gt; </td></tr>
<tr class="memitem:ga5f6ae28ba3a684c889d97135251a2a8d"><td class="memTemplItemLeft" align="right" valign="top">mat&lt; T, C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga5f6ae28ba3a684c889d97135251a2a8d">tue::math::sin</a> (const mat&lt; T, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:ga5f6ae28ba3a684c889d97135251a2a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>tue::math::sin()</code> for each component of <code>m</code>.  <a href="group__mat__hpp.html#ga5f6ae28ba3a684c889d97135251a2a8d">More...</a><br /></td></tr>
<tr class="separator:ga5f6ae28ba3a684c889d97135251a2a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58ca317305f155313cbab62f1cab8ddd"><td class="memTemplParams" colspan="2">template&lt;typename T , int C, int R&gt; </td></tr>
<tr class="memitem:ga58ca317305f155313cbab62f1cab8ddd"><td class="memTemplItemLeft" align="right" valign="top">mat&lt; T, C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga58ca317305f155313cbab62f1cab8ddd">tue::math::cos</a> (const mat&lt; T, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:ga58ca317305f155313cbab62f1cab8ddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>tue::math::cos()</code> for each component of <code>m</code>.  <a href="group__mat__hpp.html#ga58ca317305f155313cbab62f1cab8ddd">More...</a><br /></td></tr>
<tr class="separator:ga58ca317305f155313cbab62f1cab8ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14a144006bf050cae7763d80abfcb159"><td class="memTemplParams" colspan="2">template&lt;typename T , int C, int R&gt; </td></tr>
<tr class="memitem:ga14a144006bf050cae7763d80abfcb159"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga14a144006bf050cae7763d80abfcb159">tue::math::sincos</a> (const mat&lt; T, C, R &gt; &amp;m, mat&lt; T, C, R &gt; &amp;sin_out, mat&lt; T, C, R &gt; &amp;cos_out) noexcept</td></tr>
<tr class="memdesc:ga14a144006bf050cae7763d80abfcb159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>tue::math::sincos()</code> for each component of <code>m</code>.  <a href="group__mat__hpp.html#ga14a144006bf050cae7763d80abfcb159">More...</a><br /></td></tr>
<tr class="separator:ga14a144006bf050cae7763d80abfcb159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc38cd877f3644db338bd51fa16b3966"><td class="memTemplParams" colspan="2">template&lt;typename T , int C, int R&gt; </td></tr>
<tr class="memitem:gacc38cd877f3644db338bd51fa16b3966"><td class="memTemplItemLeft" align="right" valign="top">mat&lt; T, C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gacc38cd877f3644db338bd51fa16b3966">tue::math::exp</a> (const mat&lt; T, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:gacc38cd877f3644db338bd51fa16b3966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>tue::math::exp()</code> for each component of <code>m</code>.  <a href="group__mat__hpp.html#gacc38cd877f3644db338bd51fa16b3966">More...</a><br /></td></tr>
<tr class="separator:gacc38cd877f3644db338bd51fa16b3966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e826bd5c7c1296ce0824b257bcfe30d"><td class="memTemplParams" colspan="2">template&lt;typename T , int C, int R&gt; </td></tr>
<tr class="memitem:ga1e826bd5c7c1296ce0824b257bcfe30d"><td class="memTemplItemLeft" align="right" valign="top">mat&lt; T, C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga1e826bd5c7c1296ce0824b257bcfe30d">tue::math::log</a> (const mat&lt; T, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:ga1e826bd5c7c1296ce0824b257bcfe30d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>tue::math::log()</code> for each component of <code>m</code>.  <a href="group__mat__hpp.html#ga1e826bd5c7c1296ce0824b257bcfe30d">More...</a><br /></td></tr>
<tr class="separator:ga1e826bd5c7c1296ce0824b257bcfe30d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf0fa9acb7cbd0cf42c79a515753942a"><td class="memTemplParams" colspan="2">template&lt;typename T , int C, int R&gt; </td></tr>
<tr class="memitem:gadf0fa9acb7cbd0cf42c79a515753942a"><td class="memTemplItemLeft" align="right" valign="top">mat&lt; T, C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gadf0fa9acb7cbd0cf42c79a515753942a">tue::math::abs</a> (const mat&lt; T, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:gadf0fa9acb7cbd0cf42c79a515753942a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>tue::math::abs()</code> for each component of <code>m</code>.  <a href="group__mat__hpp.html#gadf0fa9acb7cbd0cf42c79a515753942a">More...</a><br /></td></tr>
<tr class="separator:gadf0fa9acb7cbd0cf42c79a515753942a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga254225b7863108d2cef2730afddd1baa"><td class="memTemplParams" colspan="2">template&lt;typename T , int C, int R&gt; </td></tr>
<tr class="memitem:ga254225b7863108d2cef2730afddd1baa"><td class="memTemplItemLeft" align="right" valign="top">mat&lt; T, C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga254225b7863108d2cef2730afddd1baa">tue::math::pow</a> (const mat&lt; T, C, R &gt; &amp;bases, const mat&lt; T, C, R &gt; &amp;exponents) noexcept</td></tr>
<tr class="memdesc:ga254225b7863108d2cef2730afddd1baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>tue::math::pow()</code> for each component of <code>bases</code> and each corresponding component of <code>exponents</code>.  <a href="group__mat__hpp.html#ga254225b7863108d2cef2730afddd1baa">More...</a><br /></td></tr>
<tr class="separator:ga254225b7863108d2cef2730afddd1baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c4f9ff2bc3638da0909144363d66912"><td class="memTemplParams" colspan="2">template&lt;typename T , int C, int R&gt; </td></tr>
<tr class="memitem:ga5c4f9ff2bc3638da0909144363d66912"><td class="memTemplItemLeft" align="right" valign="top">mat&lt; T, C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga5c4f9ff2bc3638da0909144363d66912">tue::math::recip</a> (const mat&lt; T, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:ga5c4f9ff2bc3638da0909144363d66912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>tue::math::recip()</code> for each component of <code>m</code>.  <a href="group__mat__hpp.html#ga5c4f9ff2bc3638da0909144363d66912">More...</a><br /></td></tr>
<tr class="separator:ga5c4f9ff2bc3638da0909144363d66912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2728551ee1c66d43ced049f76dd570fe"><td class="memTemplParams" colspan="2">template&lt;typename T , int C, int R&gt; </td></tr>
<tr class="memitem:ga2728551ee1c66d43ced049f76dd570fe"><td class="memTemplItemLeft" align="right" valign="top">mat&lt; T, C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga2728551ee1c66d43ced049f76dd570fe">tue::math::sqrt</a> (const mat&lt; T, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:ga2728551ee1c66d43ced049f76dd570fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>tue::math::sqrt()</code> for each component of <code>m</code>.  <a href="group__mat__hpp.html#ga2728551ee1c66d43ced049f76dd570fe">More...</a><br /></td></tr>
<tr class="separator:ga2728551ee1c66d43ced049f76dd570fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac007ddc51128fdc36624ec4b24e5c0a9"><td class="memTemplParams" colspan="2">template&lt;typename T , int C, int R&gt; </td></tr>
<tr class="memitem:gac007ddc51128fdc36624ec4b24e5c0a9"><td class="memTemplItemLeft" align="right" valign="top">mat&lt; T, C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gac007ddc51128fdc36624ec4b24e5c0a9">tue::math::rsqrt</a> (const mat&lt; T, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:gac007ddc51128fdc36624ec4b24e5c0a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>tue::math::rsqrt()</code> for each component of <code>m</code>.  <a href="group__mat__hpp.html#gac007ddc51128fdc36624ec4b24e5c0a9">More...</a><br /></td></tr>
<tr class="separator:gac007ddc51128fdc36624ec4b24e5c0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fc22b68face47b6cb954e14249db350"><td class="memTemplParams" colspan="2">template&lt;typename T , int C, int R&gt; </td></tr>
<tr class="memitem:ga5fc22b68face47b6cb954e14249db350"><td class="memTemplItemLeft" align="right" valign="top">mat&lt; T, C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga5fc22b68face47b6cb954e14249db350">tue::math::min</a> (const mat&lt; T, C, R &gt; &amp;m1, const mat&lt; T, C, R &gt; &amp;m2) noexcept</td></tr>
<tr class="memdesc:ga5fc22b68face47b6cb954e14249db350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>tue::math::min()</code> for each corresponding pair of components from <code>m1</code> and <code>m2</code>.  <a href="group__mat__hpp.html#ga5fc22b68face47b6cb954e14249db350">More...</a><br /></td></tr>
<tr class="separator:ga5fc22b68face47b6cb954e14249db350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2af2897af4ed159329dbe559c6af3b23"><td class="memTemplParams" colspan="2">template&lt;typename T , int C, int R&gt; </td></tr>
<tr class="memitem:ga2af2897af4ed159329dbe559c6af3b23"><td class="memTemplItemLeft" align="right" valign="top">mat&lt; T, C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga2af2897af4ed159329dbe559c6af3b23">tue::math::max</a> (const mat&lt; T, C, R &gt; &amp;m1, const mat&lt; T, C, R &gt; &amp;m2) noexcept</td></tr>
<tr class="memdesc:ga2af2897af4ed159329dbe559c6af3b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>tue::math::max()</code> for each corresponding pair of components from <code>m1</code> and <code>m2</code>.  <a href="group__mat__hpp.html#ga2af2897af4ed159329dbe559c6af3b23">More...</a><br /></td></tr>
<tr class="separator:ga2af2897af4ed159329dbe559c6af3b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7d61622d424afd55c5babff0e169a48"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:gaa7d61622d424afd55c5babff0e169a48"><td class="memTemplItemLeft" align="right" valign="top">mat&lt; U, C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gaa7d61622d424afd55c5babff0e169a48">tue::math::mask</a> (const mat&lt; T, C, R &gt; &amp;conditions, const mat&lt; U, C, R &gt; &amp;values) noexcept</td></tr>
<tr class="memdesc:gaa7d61622d424afd55c5babff0e169a48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>tue::math::mask()</code> for each corresponding pair of components from <code>conditions</code> and <code>values</code>.  <a href="group__mat__hpp.html#gaa7d61622d424afd55c5babff0e169a48">More...</a><br /></td></tr>
<tr class="separator:gaa7d61622d424afd55c5babff0e169a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a4dca6290c3689f56dc244878964b1c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga5a4dca6290c3689f56dc244878964b1c"><td class="memTemplItemLeft" align="right" valign="top">mat&lt; U, C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga5a4dca6290c3689f56dc244878964b1c">tue::math::select</a> (const mat&lt; T, C, R &gt; &amp;conditions, const mat&lt; U, C, R &gt; &amp;values, const mat&lt; U, C, R &gt; &amp;otherwise) noexcept</td></tr>
<tr class="memdesc:ga5a4dca6290c3689f56dc244878964b1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>tue::math::select()</code> for each corresponding trio of components from <code>conditions</code>, <code>values</code>, and <code>otherwise</code>.  <a href="group__mat__hpp.html#ga5a4dca6290c3689f56dc244878964b1c">More...</a><br /></td></tr>
<tr class="separator:ga5a4dca6290c3689f56dc244878964b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50fcc530e9c5fd072068b4cc3cecfd56"><td class="memTemplParams" colspan="2">template&lt;typename T , int C, int R&gt; </td></tr>
<tr class="memitem:ga50fcc530e9c5fd072068b4cc3cecfd56"><td class="memTemplItemLeft" align="right" valign="top">mat&lt; decltype(tue::math::less(std::declval&lt; T &gt;), std::declval&lt; T &gt;))), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga50fcc530e9c5fd072068b4cc3cecfd56">tue::math::less</a> (const mat&lt; T, C, R &gt; &amp;lhs, const mat&lt; T, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga50fcc530e9c5fd072068b4cc3cecfd56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>tue::math::less()</code> for each corresponding pair of components from <code>lhs</code> and <code>rhs</code>.  <a href="group__mat__hpp.html#ga50fcc530e9c5fd072068b4cc3cecfd56">More...</a><br /></td></tr>
<tr class="separator:ga50fcc530e9c5fd072068b4cc3cecfd56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50fa24240abb35fac25167a2c8fbf517"><td class="memTemplParams" colspan="2">template&lt;typename T , int C, int R&gt; </td></tr>
<tr class="memitem:ga50fa24240abb35fac25167a2c8fbf517"><td class="memTemplItemLeft" align="right" valign="top">mat&lt; decltype(tue::math::less_equal(std::declval&lt; T &gt;), std::declval&lt; T &gt;))), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga50fa24240abb35fac25167a2c8fbf517">tue::math::less_equal</a> (const mat&lt; T, C, R &gt; &amp;lhs, const mat&lt; T, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga50fa24240abb35fac25167a2c8fbf517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>tue::math::less_equal()</code> for each corresponding pair of components from <code>lhs</code> and <code>rhs</code>.  <a href="group__mat__hpp.html#ga50fa24240abb35fac25167a2c8fbf517">More...</a><br /></td></tr>
<tr class="separator:ga50fa24240abb35fac25167a2c8fbf517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd58f23eb73e050c4f73b8eb1e8e337a"><td class="memTemplParams" colspan="2">template&lt;typename T , int C, int R&gt; </td></tr>
<tr class="memitem:gadd58f23eb73e050c4f73b8eb1e8e337a"><td class="memTemplItemLeft" align="right" valign="top">mat&lt; decltype(tue::math::greater(std::declval&lt; T &gt;), std::declval&lt; T &gt;))), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gadd58f23eb73e050c4f73b8eb1e8e337a">tue::math::greater</a> (const mat&lt; T, C, R &gt; &amp;lhs, const mat&lt; T, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:gadd58f23eb73e050c4f73b8eb1e8e337a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>tue::math::greater()</code> for each corresponding pair of components from <code>lhs</code> and <code>rhs</code>.  <a href="group__mat__hpp.html#gadd58f23eb73e050c4f73b8eb1e8e337a">More...</a><br /></td></tr>
<tr class="separator:gadd58f23eb73e050c4f73b8eb1e8e337a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d252c6d3d29f8d1d5c731e2f540c073"><td class="memTemplParams" colspan="2">template&lt;typename T , int C, int R&gt; </td></tr>
<tr class="memitem:ga1d252c6d3d29f8d1d5c731e2f540c073"><td class="memTemplItemLeft" align="right" valign="top">mat&lt; decltype(tue::math::greater_equal(std::declval&lt; T &gt;), std::declval&lt; T &gt;))), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga1d252c6d3d29f8d1d5c731e2f540c073">tue::math::greater_equal</a> (const mat&lt; T, C, R &gt; &amp;lhs, const mat&lt; T, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga1d252c6d3d29f8d1d5c731e2f540c073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>tue::math::greater_equal()</code> for each corresponding pair of components from <code>lhs</code> and <code>rhs</code>.  <a href="group__mat__hpp.html#ga1d252c6d3d29f8d1d5c731e2f540c073">More...</a><br /></td></tr>
<tr class="separator:ga1d252c6d3d29f8d1d5c731e2f540c073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1731c7c5eed88e40d51d2f44a26bbfe0"><td class="memTemplParams" colspan="2">template&lt;typename T , int C, int R&gt; </td></tr>
<tr class="memitem:ga1731c7c5eed88e40d51d2f44a26bbfe0"><td class="memTemplItemLeft" align="right" valign="top">mat&lt; decltype(tue::math::equal(std::declval&lt; T &gt;), std::declval&lt; T &gt;))), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga1731c7c5eed88e40d51d2f44a26bbfe0">tue::math::equal</a> (const mat&lt; T, C, R &gt; &amp;lhs, const mat&lt; T, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga1731c7c5eed88e40d51d2f44a26bbfe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>tue::math::equal()</code> for each corresponding pair of components from <code>lhs</code> and <code>rhs</code>.  <a href="group__mat__hpp.html#ga1731c7c5eed88e40d51d2f44a26bbfe0">More...</a><br /></td></tr>
<tr class="separator:ga1731c7c5eed88e40d51d2f44a26bbfe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22e9bbb204c5746bff6e491b507c25d4"><td class="memTemplParams" colspan="2">template&lt;typename T , int C, int R&gt; </td></tr>
<tr class="memitem:ga22e9bbb204c5746bff6e491b507c25d4"><td class="memTemplItemLeft" align="right" valign="top">mat&lt; decltype(tue::math::not_equal(std::declval&lt; T &gt;), std::declval&lt; T &gt;))), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga22e9bbb204c5746bff6e491b507c25d4">tue::math::not_equal</a> (const mat&lt; T, C, R &gt; &amp;lhs, const mat&lt; T, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga22e9bbb204c5746bff6e491b507c25d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>tue::math::not_equal()</code> for each corresponding pair of components from <code>lhs</code> and <code>rhs</code>.  <a href="group__mat__hpp.html#ga22e9bbb204c5746bff6e491b507c25d4">More...</a><br /></td></tr>
<tr class="separator:ga22e9bbb204c5746bff6e491b507c25d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa37f59e665e253f02c579b554cf4ffa2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:gaa37f59e665e253f02c579b554cf4ffa2"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gaa37f59e665e253f02c579b554cf4ffa2">tue::math::comp_mult</a> (const mat&lt; T, C, R &gt; &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:gaa37f59e665e253f02c579b554cf4ffa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the products of each component of <code>lhs</code> and each corresponding component of <code>rhs</code>.  <a href="group__mat__hpp.html#gaa37f59e665e253f02c579b554cf4ffa2">More...</a><br /></td></tr>
<tr class="separator:gaa37f59e665e253f02c579b554cf4ffa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17206c5ab12e4aaa5405f76dbf77863a"><td class="memTemplParams" colspan="2">template&lt;typename T , int C, int R&gt; </td></tr>
<tr class="memitem:ga17206c5ab12e4aaa5405f76dbf77863a"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; T, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga17206c5ab12e4aaa5405f76dbf77863a">tue::math::transpose</a> (const mat&lt; T, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:ga17206c5ab12e4aaa5405f76dbf77863a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the transpose of <code>m</code>.  <a href="group__mat__hpp.html#ga17206c5ab12e4aaa5405f76dbf77863a">More...</a><br /></td></tr>
<tr class="separator:ga17206c5ab12e4aaa5405f76dbf77863a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The <code>mat</code> class template and its associated functions. </p>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="classtue_1_1mat" id="classtue_1_1mat"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class tue::mat</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T, int C, int R&gt;<br />
class tue::mat&lt; T, C, R &gt;</h3>

<p>A column-major matrix. </p>
<p><code>mat</code> have the same size and alignment requirements as <code>vec&lt;T, R&gt;[C]</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type. <code>is_vec_component&lt;T&gt;value</code> must be <code>true</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count. Must be <code>2</code>, <code>3</code>, or <code>4</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count. Must be <code>2</code>, <code>3</code>, or <code>4</code>. </td></tr>
  </table>
  </dd>
</dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Types</h3></td></tr>
<tr class="memitem:ac59de3ee035711a062d65524604ac589"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ac59de3ee035711a062d65524604ac589">component_type</a> = T</td></tr>
<tr class="memdesc:ac59de3ee035711a062d65524604ac589"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <code>mat</code> type's component type.  <a href="#ac59de3ee035711a062d65524604ac589">More...</a><br /></td></tr>
<tr class="separator:ac59de3ee035711a062d65524604ac589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:ab733634293348ba649a9a35914aff268"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ab733634293348ba649a9a35914aff268">mat</a> () noexcept=default</td></tr>
<tr class="memdesc:ab733634293348ba649a9a35914aff268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructs each component.  <a href="#ab733634293348ba649a9a35914aff268">More...</a><br /></td></tr>
<tr class="separator:ab733634293348ba649a9a35914aff268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f46807f349d360ece5885ee5adcf5c"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a95f46807f349d360ece5885ee5adcf5c">mat</a> (const T &amp;x) noexcept</td></tr>
<tr class="memdesc:a95f46807f349d360ece5885ee5adcf5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs each component along the main diagonal with the same value, and all other components with <code>0</code>.  <a href="#a95f46807f349d360ece5885ee5adcf5c">More...</a><br /></td></tr>
<tr class="separator:a95f46807f349d360ece5885ee5adcf5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e34d5d7d491f3421dcb8a4fa4b9556"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a16e34d5d7d491f3421dcb8a4fa4b9556">mat</a> (const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:a16e34d5d7d491f3421dcb8a4fa4b9556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs each column with the same values.  <a href="#a16e34d5d7d491f3421dcb8a4fa4b9556">More...</a><br /></td></tr>
<tr class="separator:a16e34d5d7d491f3421dcb8a4fa4b9556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212aee0ad727c3c67bbffa3c1d503f93"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a212aee0ad727c3c67bbffa3c1d503f93">mat</a> (const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;c0, const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;c1) noexcept</td></tr>
<tr class="memdesc:a212aee0ad727c3c67bbffa3c1d503f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <code>mat</code> with the given columns.  <a href="#a212aee0ad727c3c67bbffa3c1d503f93">More...</a><br /></td></tr>
<tr class="separator:a212aee0ad727c3c67bbffa3c1d503f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0f0b5c4637727dcd51b68907889160"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a2e0f0b5c4637727dcd51b68907889160">mat</a> (const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;c0, const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;c1, const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;c2) noexcept</td></tr>
<tr class="memdesc:a2e0f0b5c4637727dcd51b68907889160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <code>mat</code> with the given columns.  <a href="#a2e0f0b5c4637727dcd51b68907889160">More...</a><br /></td></tr>
<tr class="separator:a2e0f0b5c4637727dcd51b68907889160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4d5d00d5045d0865c171146c5d1389"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a9c4d5d00d5045d0865c171146c5d1389">mat</a> (const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;c0, const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;c1, const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;c2, const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;c3) noexcept</td></tr>
<tr class="memdesc:a9c4d5d00d5045d0865c171146c5d1389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <code>mat</code> with the given columns.  <a href="#a9c4d5d00d5045d0865c171146c5d1389">More...</a><br /></td></tr>
<tr class="separator:a9c4d5d00d5045d0865c171146c5d1389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba84aaf49142243f54f3231d1415f5a"><td class="memTemplParams" colspan="2">template&lt;int MC, int MR&gt; </td></tr>
<tr class="memitem:a7ba84aaf49142243f54f3231d1415f5a"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a7ba84aaf49142243f54f3231d1415f5a">mat</a> (const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, MC, MR &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:a7ba84aaf49142243f54f3231d1415f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly casts another <code>mat</code> to a new size.  <a href="#a7ba84aaf49142243f54f3231d1415f5a">More...</a><br /></td></tr>
<tr class="separator:a7ba84aaf49142243f54f3231d1415f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c1359ba5433401196203f22fc33fc5"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:ac6c1359ba5433401196203f22fc33fc5"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ac6c1359ba5433401196203f22fc33fc5">mat</a> (const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:ac6c1359ba5433401196203f22fc33fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly casts another <code>mat</code> to a new component type.  <a href="#ac6c1359ba5433401196203f22fc33fc5">More...</a><br /></td></tr>
<tr class="separator:ac6c1359ba5433401196203f22fc33fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4e36d7c3615ceedf46fbf7227f30d7"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a6d4e36d7c3615ceedf46fbf7227f30d7"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a6d4e36d7c3615ceedf46fbf7227f30d7">operator mat&lt; U, C, R &gt;</a> () const  noexcept</td></tr>
<tr class="memdesc:a6d4e36d7c3615ceedf46fbf7227f30d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicitly casts this <code>mat</code> to a new component type.  <a href="#a6d4e36d7c3615ceedf46fbf7227f30d7">More...</a><br /></td></tr>
<tr class="separator:a6d4e36d7c3615ceedf46fbf7227f30d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8af6669a032ac2b7b2e59bc93d086b9"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:ac8af6669a032ac2b7b2e59bc93d086b9"><td class="memTemplItemLeft" align="right" valign="top">constexpr const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ac8af6669a032ac2b7b2e59bc93d086b9">operator[]</a> (const I &amp;i) const  noexcept</td></tr>
<tr class="memdesc:ac8af6669a032ac2b7b2e59bc93d086b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the column at the given index.  <a href="#ac8af6669a032ac2b7b2e59bc93d086b9">More...</a><br /></td></tr>
<tr class="separator:ac8af6669a032ac2b7b2e59bc93d086b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72569a23e1168e7fd5b418d911d4213c"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:a72569a23e1168e7fd5b418d911d4213c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a72569a23e1168e7fd5b418d911d4213c">operator[]</a> (const I &amp;i) noexcept</td></tr>
<tr class="memdesc:a72569a23e1168e7fd5b418d911d4213c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the column at the given index.  <a href="#a72569a23e1168e7fd5b418d911d4213c">More...</a><br /></td></tr>
<tr class="separator:a72569a23e1168e7fd5b418d911d4213c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5ab1fc315e949ee99e6d08a619fe19"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a7f5ab1fc315e949ee99e6d08a619fe19">data</a> () const  noexcept</td></tr>
<tr class="memdesc:a7f5ab1fc315e949ee99e6d08a619fe19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to this <code>mat</code>'s underlying component array.  <a href="#a7f5ab1fc315e949ee99e6d08a619fe19">More...</a><br /></td></tr>
<tr class="separator:a7f5ab1fc315e949ee99e6d08a619fe19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7984d48245a53e6a753782ca5c637272"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a7984d48245a53e6a753782ca5c637272">data</a> () noexcept</td></tr>
<tr class="memdesc:a7984d48245a53e6a753782ca5c637272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to this <code>mat</code>'s underlying component array.  <a href="#a7984d48245a53e6a753782ca5c637272">More...</a><br /></td></tr>
<tr class="separator:a7984d48245a53e6a753782ca5c637272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a283acca55758c76109596c9869951243"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a283acca55758c76109596c9869951243">columns</a> () const  noexcept</td></tr>
<tr class="memdesc:a283acca55758c76109596c9869951243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to this <code>mat</code>'s underlying column array.  <a href="#a283acca55758c76109596c9869951243">More...</a><br /></td></tr>
<tr class="separator:a283acca55758c76109596c9869951243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e803f188c46a4fec0307345472e323"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a74e803f188c46a4fec0307345472e323">columns</a> () noexcept</td></tr>
<tr class="memdesc:a74e803f188c46a4fec0307345472e323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to this <code>mat</code>'s underlying column array.  <a href="#a74e803f188c46a4fec0307345472e323">More...</a><br /></td></tr>
<tr class="separator:a74e803f188c46a4fec0307345472e323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193524ed5d0203e01d8a2af82845e6e0"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:a193524ed5d0203e01d8a2af82845e6e0"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a193524ed5d0203e01d8a2af82845e6e0">column</a> (const I &amp;i) const  noexcept</td></tr>
<tr class="memdesc:a193524ed5d0203e01d8a2af82845e6e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the column at the given index.  <a href="#a193524ed5d0203e01d8a2af82845e6e0">More...</a><br /></td></tr>
<tr class="separator:a193524ed5d0203e01d8a2af82845e6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4db9c57fb1b07a97ca699e6b152d1ec"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:ab4db9c57fb1b07a97ca699e6b152d1ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ab4db9c57fb1b07a97ca699e6b152d1ec">set_column</a> (const I &amp;i, const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:ab4db9c57fb1b07a97ca699e6b152d1ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the values of the column at the given index.  <a href="#ab4db9c57fb1b07a97ca699e6b152d1ec">More...</a><br /></td></tr>
<tr class="separator:ab4db9c57fb1b07a97ca699e6b152d1ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19fef97f39f6a96c03070ba1fbdbb391"><td class="memTemplParams" colspan="2">template&lt;typename J &gt; </td></tr>
<tr class="memitem:a19fef97f39f6a96c03070ba1fbdbb391"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a19fef97f39f6a96c03070ba1fbdbb391">row</a> (const J &amp;j) const  noexcept</td></tr>
<tr class="memdesc:a19fef97f39f6a96c03070ba1fbdbb391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the row at the given index.  <a href="#a19fef97f39f6a96c03070ba1fbdbb391">More...</a><br /></td></tr>
<tr class="separator:a19fef97f39f6a96c03070ba1fbdbb391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb077aa62c88189629c6e8dd84a53a2b"><td class="memTemplParams" colspan="2">template&lt;typename J &gt; </td></tr>
<tr class="memitem:afb077aa62c88189629c6e8dd84a53a2b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#afb077aa62c88189629c6e8dd84a53a2b">set_row</a> (const J &amp;j, const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, C &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:afb077aa62c88189629c6e8dd84a53a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the values of the row at the given index.  <a href="#afb077aa62c88189629c6e8dd84a53a2b">More...</a><br /></td></tr>
<tr class="separator:afb077aa62c88189629c6e8dd84a53a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022e2effac766a115d12e70ac4d27567"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a022e2effac766a115d12e70ac4d27567">operator++</a> () noexcept</td></tr>
<tr class="memdesc:a022e2effac766a115d12e70ac4d27567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre-increments each component of this <code>mat</code>.  <a href="#a022e2effac766a115d12e70ac4d27567">More...</a><br /></td></tr>
<tr class="separator:a022e2effac766a115d12e70ac4d27567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d86439ddf6d96be7fd138b0bd04f3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a28d86439ddf6d96be7fd138b0bd04f3b">operator++</a> (int) noexcept</td></tr>
<tr class="memdesc:a28d86439ddf6d96be7fd138b0bd04f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post-increments each component of this <code>mat</code>.  <a href="#a28d86439ddf6d96be7fd138b0bd04f3b">More...</a><br /></td></tr>
<tr class="separator:a28d86439ddf6d96be7fd138b0bd04f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62364eafe8e7610b4dcb7aea7e1e5af3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a62364eafe8e7610b4dcb7aea7e1e5af3">operator--</a> () noexcept</td></tr>
<tr class="memdesc:a62364eafe8e7610b4dcb7aea7e1e5af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre-decrements each component of this <code>mat</code>.  <a href="#a62364eafe8e7610b4dcb7aea7e1e5af3">More...</a><br /></td></tr>
<tr class="separator:a62364eafe8e7610b4dcb7aea7e1e5af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d0a72082f65007dd7cb0ccab5714eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a93d0a72082f65007dd7cb0ccab5714eb">operator--</a> (int) noexcept</td></tr>
<tr class="memdesc:a93d0a72082f65007dd7cb0ccab5714eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post-decrements each component of this <code>mat</code>.  <a href="#a93d0a72082f65007dd7cb0ccab5714eb">More...</a><br /></td></tr>
<tr class="separator:a93d0a72082f65007dd7cb0ccab5714eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093595d4ecf9d2038f6020d4f5599838"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a093595d4ecf9d2038f6020d4f5599838"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="group__vec__hpp.html#structtue_1_1is__vec__component">is_vec_component</a>&lt; U &gt;::value, <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a093595d4ecf9d2038f6020d4f5599838">operator+=</a> (const U &amp;x) noexcept</td></tr>
<tr class="memdesc:a093595d4ecf9d2038f6020d4f5599838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds <code>x</code> to each component of this <code>mat</code>.  <a href="#a093595d4ecf9d2038f6020d4f5599838">More...</a><br /></td></tr>
<tr class="separator:a093595d4ecf9d2038f6020d4f5599838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc4393f4e76c066018cadc743654009"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:afbc4393f4e76c066018cadc743654009"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#afbc4393f4e76c066018cadc743654009">operator+=</a> (const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:afbc4393f4e76c066018cadc743654009"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds each component of <code>m</code> to the corresponding component of this <code>mat</code>.  <a href="#afbc4393f4e76c066018cadc743654009">More...</a><br /></td></tr>
<tr class="separator:afbc4393f4e76c066018cadc743654009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb7cdd922afa21004ea47cf3d98934d"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:aebb7cdd922afa21004ea47cf3d98934d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="group__vec__hpp.html#structtue_1_1is__vec__component">is_vec_component</a>&lt; U &gt;::value, <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#aebb7cdd922afa21004ea47cf3d98934d">operator-=</a> (const U &amp;x) noexcept</td></tr>
<tr class="memdesc:aebb7cdd922afa21004ea47cf3d98934d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts <code>x</code> from each component of this <code>mat</code>.  <a href="#aebb7cdd922afa21004ea47cf3d98934d">More...</a><br /></td></tr>
<tr class="separator:aebb7cdd922afa21004ea47cf3d98934d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54769f745dc7fc3f28c39bd605c0eecc"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a54769f745dc7fc3f28c39bd605c0eecc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a54769f745dc7fc3f28c39bd605c0eecc">operator-=</a> (const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:a54769f745dc7fc3f28c39bd605c0eecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts each component of <code>m</code> from the corresponding component of this <code>mat</code>.  <a href="#a54769f745dc7fc3f28c39bd605c0eecc">More...</a><br /></td></tr>
<tr class="separator:a54769f745dc7fc3f28c39bd605c0eecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a2bc36e0227f6153744891dc7d2a42"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a13a2bc36e0227f6153744891dc7d2a42"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="group__vec__hpp.html#structtue_1_1is__vec__component">is_vec_component</a>&lt; U &gt;::value, <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a13a2bc36e0227f6153744891dc7d2a42">operator*=</a> (const U &amp;x) noexcept</td></tr>
<tr class="memdesc:a13a2bc36e0227f6153744891dc7d2a42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies each component of this <code>mat</code> by <code>x</code>.  <a href="#a13a2bc36e0227f6153744891dc7d2a42">More...</a><br /></td></tr>
<tr class="separator:a13a2bc36e0227f6153744891dc7d2a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0efbbdd776568b21e01f9a5e0bf23475"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a0efbbdd776568b21e01f9a5e0bf23475"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a0efbbdd776568b21e01f9a5e0bf23475">operator*=</a> (const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, C &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:a0efbbdd776568b21e01f9a5e0bf23475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix multiplies this mat by <code>m</code>.  <a href="#a0efbbdd776568b21e01f9a5e0bf23475">More...</a><br /></td></tr>
<tr class="separator:a0efbbdd776568b21e01f9a5e0bf23475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21a130f23fb286bca35d338cd01c115"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:ae21a130f23fb286bca35d338cd01c115"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="group__vec__hpp.html#structtue_1_1is__vec__component">is_vec_component</a>&lt; U &gt;::value, <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ae21a130f23fb286bca35d338cd01c115">operator/=</a> (const U &amp;x) noexcept</td></tr>
<tr class="memdesc:ae21a130f23fb286bca35d338cd01c115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides each component of this <code>mat</code> by <code>x</code>.  <a href="#ae21a130f23fb286bca35d338cd01c115">More...</a><br /></td></tr>
<tr class="separator:ae21a130f23fb286bca35d338cd01c115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c74e0e744465a7410a02a383cc49cc"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a07c74e0e744465a7410a02a383cc49cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a07c74e0e744465a7410a02a383cc49cc">operator/=</a> (const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:a07c74e0e744465a7410a02a383cc49cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides each component of this <code>mat</code> by the corresponding component from <code>m</code>.  <a href="#a07c74e0e744465a7410a02a383cc49cc">More...</a><br /></td></tr>
<tr class="separator:a07c74e0e744465a7410a02a383cc49cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb64311f5ab31d80a5742336adf13b3a"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:abb64311f5ab31d80a5742336adf13b3a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="group__vec__hpp.html#structtue_1_1is__vec__component">is_vec_component</a>&lt; U &gt;::value, <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#abb64311f5ab31d80a5742336adf13b3a">operator%=</a> (const U &amp;x) noexcept</td></tr>
<tr class="memdesc:abb64311f5ab31d80a5742336adf13b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modulos each component of this <code>mat</code> by <code>x</code>.  <a href="#abb64311f5ab31d80a5742336adf13b3a">More...</a><br /></td></tr>
<tr class="separator:abb64311f5ab31d80a5742336adf13b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f77553ed195075427125ab55e624ec"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a15f77553ed195075427125ab55e624ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a15f77553ed195075427125ab55e624ec">operator%=</a> (const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:a15f77553ed195075427125ab55e624ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modulos each component of this <code>mat</code> by the corresponding component from <code>m</code>.  <a href="#a15f77553ed195075427125ab55e624ec">More...</a><br /></td></tr>
<tr class="separator:a15f77553ed195075427125ab55e624ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20bf26c4bba39f8821bd0e13381f66e3"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a20bf26c4bba39f8821bd0e13381f66e3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="group__vec__hpp.html#structtue_1_1is__vec__component">is_vec_component</a>&lt; U &gt;::value, <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a20bf26c4bba39f8821bd0e13381f66e3">operator&amp;=</a> (const U &amp;x) noexcept</td></tr>
<tr class="memdesc:a20bf26c4bba39f8821bd0e13381f66e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise ANDs each component of this <code>mat</code> with <code>x</code>.  <a href="#a20bf26c4bba39f8821bd0e13381f66e3">More...</a><br /></td></tr>
<tr class="separator:a20bf26c4bba39f8821bd0e13381f66e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8aafda72f0ecaac4c5ef57e7ef01113"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:af8aafda72f0ecaac4c5ef57e7ef01113"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#af8aafda72f0ecaac4c5ef57e7ef01113">operator&amp;=</a> (const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:af8aafda72f0ecaac4c5ef57e7ef01113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise ANDs each component of this <code>mat</code> with the corresponding component from <code>m</code>.  <a href="#af8aafda72f0ecaac4c5ef57e7ef01113">More...</a><br /></td></tr>
<tr class="separator:af8aafda72f0ecaac4c5ef57e7ef01113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee41eb563ec9fad346aa15fb5928f0e"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a9ee41eb563ec9fad346aa15fb5928f0e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="group__vec__hpp.html#structtue_1_1is__vec__component">is_vec_component</a>&lt; U &gt;::value, <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a9ee41eb563ec9fad346aa15fb5928f0e">operator|=</a> (const U &amp;x) noexcept</td></tr>
<tr class="memdesc:a9ee41eb563ec9fad346aa15fb5928f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise ORs each component of this <code>mat</code> with <code>x</code>.  <a href="#a9ee41eb563ec9fad346aa15fb5928f0e">More...</a><br /></td></tr>
<tr class="separator:a9ee41eb563ec9fad346aa15fb5928f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19012fac9e03e39514b0ce56a6e5990d"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a19012fac9e03e39514b0ce56a6e5990d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a19012fac9e03e39514b0ce56a6e5990d">operator|=</a> (const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:a19012fac9e03e39514b0ce56a6e5990d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise ORs each component of this <code>mat</code> with the corresponding component from <code>m</code>.  <a href="#a19012fac9e03e39514b0ce56a6e5990d">More...</a><br /></td></tr>
<tr class="separator:a19012fac9e03e39514b0ce56a6e5990d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ad6c691f39015294c8901fda9a1aa8"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a49ad6c691f39015294c8901fda9a1aa8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="group__vec__hpp.html#structtue_1_1is__vec__component">is_vec_component</a>&lt; U &gt;::value, <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a49ad6c691f39015294c8901fda9a1aa8">operator^=</a> (const U &amp;x) noexcept</td></tr>
<tr class="memdesc:a49ad6c691f39015294c8901fda9a1aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise XORs each component of this <code>mat</code> with <code>x</code>.  <a href="#a49ad6c691f39015294c8901fda9a1aa8">More...</a><br /></td></tr>
<tr class="separator:a49ad6c691f39015294c8901fda9a1aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed5af7a7260f1cc45b65e373c8deb36"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a0ed5af7a7260f1cc45b65e373c8deb36"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a0ed5af7a7260f1cc45b65e373c8deb36">operator^=</a> (const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:a0ed5af7a7260f1cc45b65e373c8deb36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise XORs each component of this <code>mat</code> with the corresponding component from <code>m</code>.  <a href="#a0ed5af7a7260f1cc45b65e373c8deb36">More...</a><br /></td></tr>
<tr class="separator:a0ed5af7a7260f1cc45b65e373c8deb36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf984ee024e827cfc993d63b71461b6d"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:aaf984ee024e827cfc993d63b71461b6d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="group__vec__hpp.html#structtue_1_1is__vec__component">is_vec_component</a>&lt; U &gt;::value, <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#aaf984ee024e827cfc993d63b71461b6d">operator&lt;&lt;=</a> (const U &amp;x) noexcept</td></tr>
<tr class="memdesc:aaf984ee024e827cfc993d63b71461b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise shifts left each component of this <code>mat</code> by <code>x</code>.  <a href="#aaf984ee024e827cfc993d63b71461b6d">More...</a><br /></td></tr>
<tr class="separator:aaf984ee024e827cfc993d63b71461b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de1d21744fb1cd440e71b581f052c2b"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a6de1d21744fb1cd440e71b581f052c2b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a6de1d21744fb1cd440e71b581f052c2b">operator&lt;&lt;=</a> (const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:a6de1d21744fb1cd440e71b581f052c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise shifts left each component of this <code>mat</code> by the corresponding component from <code>m</code>.  <a href="#a6de1d21744fb1cd440e71b581f052c2b">More...</a><br /></td></tr>
<tr class="separator:a6de1d21744fb1cd440e71b581f052c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab37755b31d19dd495c7c92c32a0b55dd"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:ab37755b31d19dd495c7c92c32a0b55dd"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="group__vec__hpp.html#structtue_1_1is__vec__component">is_vec_component</a>&lt; U &gt;::value, <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ab37755b31d19dd495c7c92c32a0b55dd">operator&gt;&gt;=</a> (const U &amp;x) noexcept</td></tr>
<tr class="memdesc:ab37755b31d19dd495c7c92c32a0b55dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise shifts right each component of this <code>mat</code> by <code>x</code>.  <a href="#ab37755b31d19dd495c7c92c32a0b55dd">More...</a><br /></td></tr>
<tr class="separator:ab37755b31d19dd495c7c92c32a0b55dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbe48ebdfaee578257993a6cd5b2b49"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:afbbe48ebdfaee578257993a6cd5b2b49"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#afbbe48ebdfaee578257993a6cd5b2b49">operator&gt;&gt;=</a> (const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:afbbe48ebdfaee578257993a6cd5b2b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise shifts right each component of this <code>mat</code> by the corresponding component from <code>m</code>.  <a href="#afbbe48ebdfaee578257993a6cd5b2b49">More...</a><br /></td></tr>
<tr class="separator:afbbe48ebdfaee578257993a6cd5b2b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Static Public Member Functions</h3></td></tr>
<tr class="memitem:a4e689c865320629a34d643001375eb05"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a4e689c865320629a34d643001375eb05">fill</a> (const T &amp;x) noexcept</td></tr>
<tr class="memdesc:a4e689c865320629a34d643001375eb05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code>mat</code> with each component constructed with the same value.  <a href="#a4e689c865320629a34d643001375eb05">More...</a><br /></td></tr>
<tr class="separator:a4e689c865320629a34d643001375eb05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed86fdfdc9f5c6bdf1540e5610d363e6"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#aed86fdfdc9f5c6bdf1540e5610d363e6">identity</a> () noexcept</td></tr>
<tr class="memdesc:aed86fdfdc9f5c6bdf1540e5610d363e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code>mat</code> with the main diagonal set to <code>1</code> and all other components set to <code>0</code>.  <a href="#aed86fdfdc9f5c6bdf1540e5610d363e6">More...</a><br /></td></tr>
<tr class="separator:aed86fdfdc9f5c6bdf1540e5610d363e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af99fd2de72a8ca765e84b53f36088a65"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#af99fd2de72a8ca765e84b53f36088a65">zero</a> () noexcept</td></tr>
<tr class="memdesc:af99fd2de72a8ca765e84b53f36088a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code>mat</code> with each component set to <code>0</code>.  <a href="#af99fd2de72a8ca765e84b53f36088a65">More...</a><br /></td></tr>
<tr class="separator:af99fd2de72a8ca765e84b53f36088a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Static Public Attributes</h3></td></tr>
<tr class="memitem:a5eeed6f25114d126e0ba20b7c538382a"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a5eeed6f25114d126e0ba20b7c538382a">column_count</a> = C</td></tr>
<tr class="memdesc:a5eeed6f25114d126e0ba20b7c538382a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <code>mat</code> type's column count.  <a href="#a5eeed6f25114d126e0ba20b7c538382a">More...</a><br /></td></tr>
<tr class="separator:a5eeed6f25114d126e0ba20b7c538382a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72862d944b914eb5229c8c9f58017585"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a72862d944b914eb5229c8c9f58017585">row_count</a> = R</td></tr>
<tr class="memdesc:a72862d944b914eb5229c8c9f58017585"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <code>mat</code> type's row count.  <a href="#a72862d944b914eb5229c8c9f58017585">More...</a><br /></td></tr>
<tr class="separator:a72862d944b914eb5229c8c9f58017585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5a09135f57c3e531001408bb6e1932"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#aaf5a09135f57c3e531001408bb6e1932">component_count</a> = C * R</td></tr>
<tr class="memdesc:aaf5a09135f57c3e531001408bb6e1932"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <code>mat</code> type's component count.  <a href="#aaf5a09135f57c3e531001408bb6e1932">More...</a><br /></td></tr>
<tr class="separator:aaf5a09135f57c3e531001408bb6e1932"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Member Typedef Documentation</h4>
<a class="anchor" id="ac59de3ee035711a062d65524604ac589"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::<a class="el" href="group__mat__hpp.html#ac59de3ee035711a062d65524604ac589">component_type</a> =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This <code>mat</code> type's component type. </p>

</div>
</div>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a class="anchor" id="ab733634293348ba649a9a35914aff268"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::<a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructs each component. </p>

</div>
</div>
<a class="anchor" id="a95f46807f349d360ece5885ee5adcf5c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::<a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs each component along the main diagonal with the same value, and all other components with <code>0</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to construct the main diagonal with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a16e34d5d7d491f3421dcb8a4fa4b9556"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::<a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs each column with the same values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The values to construct each column with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a212aee0ad727c3c67bbffa3c1d503f93"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::<a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>c1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <code>mat</code> with the given columns. </p>
<p>This overload is only available when <code>C</code> equals <code>2</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c0</td><td>The first column. </td></tr>
    <tr><td class="paramname">c1</td><td>The second column. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2e0f0b5c4637727dcd51b68907889160"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::<a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <code>mat</code> with the given columns. </p>
<p>This overload is only available when <code>C</code> equals <code>3</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c0</td><td>The first column. </td></tr>
    <tr><td class="paramname">c1</td><td>The second column. </td></tr>
    <tr><td class="paramname">c2</td><td>The third column. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9c4d5d00d5045d0865c171146c5d1389"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::<a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>c3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <code>mat</code> with the given columns. </p>
<p>This overload is only available when <code>C</code> equals <code>4</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c0</td><td>The first column. </td></tr>
    <tr><td class="paramname">c1</td><td>The second column. </td></tr>
    <tr><td class="paramname">c2</td><td>The third column. </td></tr>
    <tr><td class="paramname">c3</td><td>The fourth column. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7ba84aaf49142243f54f3231d1415f5a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;int MC, int MR&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::<a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, MC, MR &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explicitly casts another <code>mat</code> to a new size. </p>
<p>If the new <code>mat</code> is larger than <code>m</code> in either dimension, the new components without corresponding components in <code>m</code> will be constructed with <code>1</code> along the main diagonal and <code>0</code> otherwise. If the new <code>mat</code> is smaller in either dimension, the components from <code>m</code> without corresponding components in the new <code>mat</code> will be ignored.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MC</td><td>The column count of <code>m</code>. </td></tr>
    <tr><td class="paramname">MR</td><td>The row count of <code>m</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The <code>mat</code> to cast from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac6c1359ba5433401196203f22fc33fc5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::<a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explicitly casts another <code>mat</code> to a new component type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The component type of <code>m</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The <code>mat</code> to cast from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a class="anchor" id="a6d4e36d7c3615ceedf46fbf7227f30d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implicitly casts this <code>mat</code> to a new component type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The new component type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <code>mat</code> with the new component type. </dd></dl>

</div>
</div>
<a class="anchor" id="a4e689c865320629a34d643001375eb05"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <code>mat</code> with each component constructed with the same value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to construct each component with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>mat</code> with each component constructed with the same value. </dd></dl>

</div>
</div>
<a class="anchor" id="aed86fdfdc9f5c6bdf1540e5610d363e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::identity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <code>mat</code> with the main diagonal set to <code>1</code> and all other components set to <code>0</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>mat</code> with the main diagonal set to <code>1</code> and all other components set to <code>0</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="af99fd2de72a8ca765e84b53f36088a65"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <code>mat</code> with each component set to <code>0</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>mat</code> with each component set to <code>0</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ac8af6669a032ac2b7b2e59bc93d086b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt;T, R&gt;&amp; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const I &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the column at the given index. </p>
<p>No bounds checking is performed. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>The index type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the column at the given index. </dd></dl>

</div>
</div>
<a class="anchor" id="a72569a23e1168e7fd5b418d911d4213c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt;T, R&gt;&amp; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const I &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the column at the given index. </p>
<p>No bounds checking is performed. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>The index type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the column at the given index. </dd></dl>

</div>
</div>
<a class="anchor" id="a7f5ab1fc315e949ee99e6d08a619fe19"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to this <code>mat</code>'s underlying component array. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to this <code>mat</code>'s underlying component array. </dd></dl>

</div>
</div>
<a class="anchor" id="a7984d48245a53e6a753782ca5c637272"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to this <code>mat</code>'s underlying component array. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to this <code>mat</code>'s underlying component array. </dd></dl>

</div>
</div>
<a class="anchor" id="a283acca55758c76109596c9869951243"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt;T, R&gt;* <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::columns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to this <code>mat</code>'s underlying column array. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to this <code>mat</code>'s underlying column array. </dd></dl>

</div>
</div>
<a class="anchor" id="a74e803f188c46a4fec0307345472e323"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt;T, R&gt;* <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::columns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to this <code>mat</code>'s underlying column array. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to this <code>mat</code>'s underlying column array. </dd></dl>

</div>
</div>
<a class="anchor" id="a193524ed5d0203e01d8a2af82845e6e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt;T, R&gt; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::column </td>
          <td>(</td>
          <td class="paramtype">const I &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the column at the given index. </p>
<p>No bounds checking is performed. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>The index type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of the column at the given index. </dd></dl>

</div>
</div>
<a class="anchor" id="ab4db9c57fb1b07a97ca699e6b152d1ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::set_column </td>
          <td>(</td>
          <td class="paramtype">const I &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the values of the column at the given index. </p>
<p>No bounds checking is performed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>The index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index. </td></tr>
    <tr><td class="paramname">v</td><td>The new values for the column. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a19fef97f39f6a96c03070ba1fbdbb391"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename J &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt;T, C&gt; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::row </td>
          <td>(</td>
          <td class="paramtype">const J &amp;&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the row at the given index. </p>
<p>No bounds checking is performed. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">J</td><td>The index type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>The index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of the row at the given index. </dd></dl>

</div>
</div>
<a class="anchor" id="afb077aa62c88189629c6e8dd84a53a2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename J &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::set_row </td>
          <td>(</td>
          <td class="paramtype">const J &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the values of the row at the given index. </p>
<p>No bounds checking is performed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">J</td><td>The index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>The index. </td></tr>
    <tr><td class="paramname">v</td><td>The new values for the row. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a022e2effac766a115d12e70ac4d27567"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pre-increments each component of this <code>mat</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a28d86439ddf6d96be7fd138b0bd04f3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Post-increments each component of this <code>mat</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A copy of this <code>mat</code> before being incremented. </dd></dl>

</div>
</div>
<a class="anchor" id="a62364eafe8e7610b4dcb7aea7e1e5af3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator-- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pre-decrements each component of this <code>mat</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a93d0a72082f65007dd7cb0ccab5714eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator-- </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Post-decrements each component of this <code>mat</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A copy of this <code>mat</code> before being decremented. </dd></dl>

</div>
</div>
<a class="anchor" id="a093595d4ecf9d2038f6020d4f5599838"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="group__vec__hpp.html#structtue_1_1is__vec__component">is_vec_component</a>&lt;U&gt;::value, <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp;&gt; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds <code>x</code> to each component of this <code>mat</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of parameter <code>x</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to add to each component of this <code>mat</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="afbc4393f4e76c066018cadc743654009"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds each component of <code>m</code> to the corresponding component of this <code>mat</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The component type of <code>m</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The values to add to each component of this <code>mat</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="aebb7cdd922afa21004ea47cf3d98934d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="group__vec__hpp.html#structtue_1_1is__vec__component">is_vec_component</a>&lt;U&gt;::value, <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp;&gt; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts <code>x</code> from each component of this <code>mat</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of parameter <code>x</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to subtract from each component of this <code>mat</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a54769f745dc7fc3f28c39bd605c0eecc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts each component of <code>m</code> from the corresponding component of this <code>mat</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The component type of <code>m</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The values to subtract from each component of this <code>mat</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a13a2bc36e0227f6153744891dc7d2a42"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="group__vec__hpp.html#structtue_1_1is__vec__component">is_vec_component</a>&lt;U&gt;::value, <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp;&gt; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies each component of this <code>mat</code> by <code>x</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of parameter <code>x</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to multiply each component of this <code>mat</code> by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a0efbbdd776568b21e01f9a5e0bf23475"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matrix multiplies this mat by <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The component type of <code>m</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A <code>mat</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ae21a130f23fb286bca35d338cd01c115"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="group__vec__hpp.html#structtue_1_1is__vec__component">is_vec_component</a>&lt;U&gt;::value, <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp;&gt; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides each component of this <code>mat</code> by <code>x</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of parameter <code>x</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to divide each component of this <code>mat</code> by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a07c74e0e744465a7410a02a383cc49cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides each component of this <code>mat</code> by the corresponding component from <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The component type of <code>m</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The values to divide each component of this <code>mat</code> by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="abb64311f5ab31d80a5742336adf13b3a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="group__vec__hpp.html#structtue_1_1is__vec__component">is_vec_component</a>&lt;U&gt;::value, <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp;&gt; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator%= </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modulos each component of this <code>mat</code> by <code>x</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of parameter <code>x</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to modulo each component of this <code>mat</code> by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a15f77553ed195075427125ab55e624ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator%= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modulos each component of this <code>mat</code> by the corresponding component from <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The component type of <code>m</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The values to modulo each component of this <code>mat</code> by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a20bf26c4bba39f8821bd0e13381f66e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="group__vec__hpp.html#structtue_1_1is__vec__component">is_vec_component</a>&lt;U&gt;::value, <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp;&gt; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise ANDs each component of this <code>mat</code> with <code>x</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of parameter <code>x</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to bitwise AND each component of this <code>mat</code> with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="af8aafda72f0ecaac4c5ef57e7ef01113"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise ANDs each component of this <code>mat</code> with the corresponding component from <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The component type of <code>m</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The values to bitwise AND each component of this <code>mat</code> with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ee41eb563ec9fad346aa15fb5928f0e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="group__vec__hpp.html#structtue_1_1is__vec__component">is_vec_component</a>&lt;U&gt;::value, <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp;&gt; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator|= </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise ORs each component of this <code>mat</code> with <code>x</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of parameter <code>x</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to bitwise OR each component of this <code>mat</code> with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a19012fac9e03e39514b0ce56a6e5990d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator|= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise ORs each component of this <code>mat</code> with the corresponding component from <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The component type of <code>m</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The values to bitwise OR each component of this <code>mat</code> with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a49ad6c691f39015294c8901fda9a1aa8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="group__vec__hpp.html#structtue_1_1is__vec__component">is_vec_component</a>&lt;U&gt;::value, <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp;&gt; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator^= </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise XORs each component of this <code>mat</code> with <code>x</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of parameter <code>x</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to bitwise XOR each component of this <code>mat</code> with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ed5af7a7260f1cc45b65e373c8deb36"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator^= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise XORs each component of this <code>mat</code> with the corresponding component from <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The component type of <code>m</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The values to bitwise XOR each component of this <code>mat</code> with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="aaf984ee024e827cfc993d63b71461b6d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="group__vec__hpp.html#structtue_1_1is__vec__component">is_vec_component</a>&lt;U&gt;::value, <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp;&gt; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator&lt;&lt;= </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise shifts left each component of this <code>mat</code> by <code>x</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of parameter <code>x</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to bitwise shift left each component of this <code>mat</code> by.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a6de1d21744fb1cd440e71b581f052c2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator&lt;&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise shifts left each component of this <code>mat</code> by the corresponding component from <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The component type of <code>m</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The values to bitwise shift left each component of this <code>mat</code> by.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ab37755b31d19dd495c7c92c32a0b55dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="group__vec__hpp.html#structtue_1_1is__vec__component">is_vec_component</a>&lt;U&gt;::value, <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp;&gt; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator&gt;&gt;= </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise shifts right each component of this <code>mat</code> by <code>x</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of parameter <code>x</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to bitwise shift right each component of this <code>mat</code> by.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="afbbe48ebdfaee578257993a6cd5b2b49"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator&gt;&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise shifts right each component of this <code>mat</code> by the corresponding component from <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The component type of <code>m</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The values to bitwise shift right each component of this <code>mat</code> by.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<h4 class="groupheader">Member Data Documentation</h4>
<a class="anchor" id="a5eeed6f25114d126e0ba20b7c538382a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::column_count = C</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This <code>mat</code> type's column count. </p>

</div>
</div>
<a class="anchor" id="a72862d944b914eb5229c8c9f58017585"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::row_count = R</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This <code>mat</code> type's row count. </p>

</div>
</div>
<a class="anchor" id="aaf5a09135f57c3e531001408bb6e1932"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::component_count = C * R</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This <code>mat</code> type's component count. </p>

</div>
</div>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga60a6d444af56a15e792baf8b579e8d92"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__mat__hpp.html#ga60a6d444af56a15e792baf8b579e8d92">tue::mat2x2</a> = typedef mat&lt;T, 2, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 2x2 matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga42b45ba8b8b912c26571ae04cf52c066"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__mat__hpp.html#ga42b45ba8b8b912c26571ae04cf52c066">tue::mat2x3</a> = typedef mat&lt;T, 2, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 2x3 matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga233a373c492e5e9a9d05958b6faf2b29"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__mat__hpp.html#ga233a373c492e5e9a9d05958b6faf2b29">tue::mat2x4</a> = typedef mat&lt;T, 2, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 2x4 matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa1cc493760cbf7f6a39d7b7c3bab406d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__mat__hpp.html#gaa1cc493760cbf7f6a39d7b7c3bab406d">tue::mat3x2</a> = typedef mat&lt;T, 3, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 3x2 matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1af37cd6fd67c0bda4030197ce6b985c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__mat__hpp.html#ga1af37cd6fd67c0bda4030197ce6b985c">tue::mat3x3</a> = typedef mat&lt;T, 3, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 3x3 matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3233f950e6bac0b09ec2fa6e567a3685"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__mat__hpp.html#ga3233f950e6bac0b09ec2fa6e567a3685">tue::mat3x4</a> = typedef mat&lt;T, 3, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 3x4 matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6e32f544eff5596e4a058422a923bc55"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__mat__hpp.html#ga6e32f544eff5596e4a058422a923bc55">tue::mat4x2</a> = typedef mat&lt;T, 4, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 4x2 matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadda0fb2a6ad36b2893014611c9b73e30"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__mat__hpp.html#gadda0fb2a6ad36b2893014611c9b73e30">tue::mat4x3</a> = typedef mat&lt;T, 4, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 4x3 matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0df1ce73b487ecda5aa0000c8e34eaa8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__mat__hpp.html#ga0df1ce73b487ecda5aa0000c8e34eaa8">tue::mat4x4</a> = typedef mat&lt;T, 4, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 4x4 matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga80e533a486177cd40ec5a94bdc361bd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__mat__hpp.html#ga80e533a486177cd40ec5a94bdc361bd1">tue::fmat2x2</a> = typedef mat2x2&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 2x2 matrix with <code>float</code> components. </p>

</div>
</div>
<a class="anchor" id="gab20dd4c9f6458bdbb4f09c55b35c9e9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__mat__hpp.html#gab20dd4c9f6458bdbb4f09c55b35c9e9c">tue::fmat2x3</a> = typedef mat2x3&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 2x3 matrix with <code>float</code> components. </p>

</div>
</div>
<a class="anchor" id="ga7d4d37b9fa3a637d223aaa851cb4aef8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__mat__hpp.html#ga7d4d37b9fa3a637d223aaa851cb4aef8">tue::fmat2x4</a> = typedef mat2x4&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 2x4 matrix with <code>float</code> components. </p>

</div>
</div>
<a class="anchor" id="gabf7fa6a602e6074e460b6e79276e31de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__mat__hpp.html#gabf7fa6a602e6074e460b6e79276e31de">tue::fmat3x2</a> = typedef mat3x2&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 3x2 matrix with <code>float</code> components. </p>

</div>
</div>
<a class="anchor" id="ga998dbb4ce3e1871515f28ddd748e5459"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__mat__hpp.html#ga998dbb4ce3e1871515f28ddd748e5459">tue::fmat3x3</a> = typedef mat3x3&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 3x3 matrix with <code>float</code> components. </p>

</div>
</div>
<a class="anchor" id="ga1c3d86c133031648485e9936e22602d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__mat__hpp.html#ga1c3d86c133031648485e9936e22602d8">tue::fmat3x4</a> = typedef mat3x4&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 3x4 matrix with <code>float</code> components. </p>

</div>
</div>
<a class="anchor" id="ga9971dc09a5b5872b7c09fec994917b5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__mat__hpp.html#ga9971dc09a5b5872b7c09fec994917b5c">tue::fmat4x2</a> = typedef mat4x2&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 4x2 matrix with <code>float</code> components. </p>

</div>
</div>
<a class="anchor" id="ga840a930e35b20bac78811420befa9826"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__mat__hpp.html#ga840a930e35b20bac78811420befa9826">tue::fmat4x3</a> = typedef mat4x3&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 4x3 matrix with <code>float</code> components. </p>

</div>
</div>
<a class="anchor" id="gae02ecf769302be1069d43a9980c6daa6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__mat__hpp.html#gae02ecf769302be1069d43a9980c6daa6">tue::fmat4x4</a> = typedef mat4x4&lt;float&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 4x4 matrix with <code>float</code> components. </p>

</div>
</div>
<a class="anchor" id="ga5b7ecdb3d7b53b4f208886d12d8e123a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__mat__hpp.html#ga5b7ecdb3d7b53b4f208886d12d8e123a">tue::dmat2x2</a> = typedef mat2x2&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 2x2 matrix with <code>double</code> components. </p>

</div>
</div>
<a class="anchor" id="gad98f27e588a223a5f3bd2bf90d59871a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__mat__hpp.html#gad98f27e588a223a5f3bd2bf90d59871a">tue::dmat2x3</a> = typedef mat2x3&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 2x3 matrix with <code>double</code> components. </p>

</div>
</div>
<a class="anchor" id="ga846ad763f3e8078e7e0260596357e527"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__mat__hpp.html#ga846ad763f3e8078e7e0260596357e527">tue::dmat2x4</a> = typedef mat2x4&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 2x4 matrix with <code>double</code> components. </p>

</div>
</div>
<a class="anchor" id="ga4705444994047a4f9d13fddb54213750"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__mat__hpp.html#ga4705444994047a4f9d13fddb54213750">tue::dmat3x2</a> = typedef mat3x2&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 3x2 matrix with <code>double</code> components. </p>

</div>
</div>
<a class="anchor" id="gafba906f634cf63e802ffddfb2d3bcd0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__mat__hpp.html#gafba906f634cf63e802ffddfb2d3bcd0a">tue::dmat3x3</a> = typedef mat3x3&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 3x3 matrix with <code>double</code> components. </p>

</div>
</div>
<a class="anchor" id="gacbcb9f2be10e2ef2a9b118fb5aa7a079"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__mat__hpp.html#gacbcb9f2be10e2ef2a9b118fb5aa7a079">tue::dmat3x4</a> = typedef mat3x4&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 3x4 matrix with <code>double</code> components. </p>

</div>
</div>
<a class="anchor" id="ga00ae9b428d4457cd2e0655b7405e81f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__mat__hpp.html#ga00ae9b428d4457cd2e0655b7405e81f0">tue::dmat4x2</a> = typedef mat4x2&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 4x2 matrix with <code>double</code> components. </p>

</div>
</div>
<a class="anchor" id="ga8c25992cc3db7e4e7b2e5689bbf54990"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__mat__hpp.html#ga8c25992cc3db7e4e7b2e5689bbf54990">tue::dmat4x3</a> = typedef mat4x3&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 4x3 matrix with <code>double</code> components. </p>

</div>
</div>
<a class="anchor" id="ga69a3b00df771a6da9d5eeaa9037c6383"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__mat__hpp.html#ga69a3b00df771a6da9d5eeaa9037c6383">tue::dmat4x4</a> = typedef mat4x4&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 4x4 matrix with <code>double</code> components. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga105c13000f760427fef886850cb232fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype(+std::declval&lt;T&gt;)), C, R&gt; tue::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the unary plus of each component of <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>m</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>m</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>m</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A <code>mat</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unary plus of each component of <code>m</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga28ee4aaf5707d2de51eff8bdc65e99ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype(-std::declval&lt;T&gt;)), C, R&gt; tue::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the unary minus of each component of <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>m</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>m</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>m</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A <code>mat</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unary minus of each component of <code>m</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa07d7dace8c23fdb460f29e46f705077"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype(~std::declval&lt;T&gt;)), C, R&gt; tue::operator~ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bitwise NOT of each component of <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>m</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>m</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>m</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A <code>mat</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bitwise NOT of each component of <code>m</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gab1644a674687d3555bd68eb11e001f58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; is_vec_component&lt;T&gt;::value, mat&lt;decltype(std::declval&lt;T&gt;) + std::declval&lt;U&gt;)), C, R&gt; &gt; tue::operator+ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sums of <code>lhs</code> and each component of <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of parameter <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sums of <code>lhs</code> and each component of <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga21e81d717d2e7a1007b6070472e1e824"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; is_vec_component&lt;U&gt;::value, mat&lt;decltype(std::declval&lt;T&gt;) + std::declval&lt;U&gt;)), C, R&gt; &gt; tue::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sums of each component of <code>lhs</code> and <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The type of parameter <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>lhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sums of each component of <code>lhs</code> and <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga797da95865c09dbb33905d289aac7d83"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype(std::declval&lt;T&gt;) + std::declval&lt;U&gt;)), C, R&gt; tue::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sums of each component of <code>lhs</code> and each corresponding component of <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of both <code>lhs</code> and <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sums of each component of <code>lhs</code> and each corresponding component of <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gafcbd8369f10ddbafca8c4644227b7c3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; is_vec_component&lt;T&gt;::value, mat&lt;decltype(std::declval&lt;T&gt;) - std::declval&lt;U&gt;)), C, R&gt; &gt; tue::operator- </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the differences between <code>lhs</code> and each component of <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of parameter <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The differences between <code>lhs</code> and each component of <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga85e116ffaf8bbf4eb9cbfd6c107ea986"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; is_vec_component&lt;U&gt;::value, mat&lt;decltype(std::declval&lt;T&gt;) - std::declval&lt;U&gt;)), C, R&gt; &gt; tue::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the differences between each component of <code>lhs</code> and <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The type of parameter <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>lhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The differences between each component of <code>lhs</code> and <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa2c8e4f0603a59fa3d6e423ef87b4c2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype(std::declval&lt;T&gt;) - std::declval&lt;U&gt;)), C, R&gt; tue::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the differences between each component of <code>lhs</code> and each corresponding component of <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of both <code>lhs</code> and <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The differences between each component of <code>lhs</code> and each corresponding component of <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gade54eaf0cc1490820a12b8eaf9a3c265"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; is_vec_component&lt;T&gt;::value, mat&lt;decltype(std::declval&lt;T&gt;) * std::declval&lt;U&gt;)), C, R&gt; &gt; tue::operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the products of <code>lhs</code> and each component of <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of parameter <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The products of <code>lhs</code> and each component of <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga724681a2c9560ba64ec32cdfdfdf54f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; is_vec_component&lt;U&gt;::value, mat&lt;decltype(std::declval&lt;T&gt;) * std::declval&lt;U&gt;)), C, R&gt; &gt; tue::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the products of each component of <code>lhs</code> and <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The type of parameter <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>lhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The products of each component of <code>lhs</code> and <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gad34bf6bf898ec2a9876d2b2cee9f535f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr vec&lt;decltype(std::declval&lt;T&gt;) * std::declval&lt;U&gt;)), C&gt; tue::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the matrix product of <code>lhs</code> and <code>rhs</code>. </p>
<p><code>lhs</code> is treated like a matrix with a single row.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The component count of <code>lhs</code> and row count of <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The matrix product of <code>lhs</code> and <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaeb7b725c10f654beaf6ac1b4c2e5e739"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr vec&lt;decltype(std::declval&lt;T&gt;) * std::declval&lt;U&gt;)), R&gt; tue::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; U, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the matrix product of <code>lhs</code> and <code>rhs</code>. </p>
<p><code>rhs</code> is treated like a matrix with a single column.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>lhs</code> and component count of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>lhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The matrix product of <code>lhs</code> and <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga496433423f8744e525f4aa9a6dadb329"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int N, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype(std::declval&lt;T&gt;) * std::declval&lt;U&gt;)), C, R&gt; tue::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, N, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the matrix product of <code>lhs</code> and <code>rhs</code>. </p>
<p>To compute the component-wise product, use <code>tue::math::comp_mult()</code> instead.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of both <code>lhs</code> and <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The matrix product of <code>lhs</code> and <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaeb089f96caec4311a221ab76729f0e9e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; is_vec_component&lt;T&gt;::value, mat&lt;decltype(std::declval&lt;T&gt;) / std::declval&lt;U&gt;)), C, R&gt; &gt; tue::operator/ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the quotients of <code>lhs</code> over each component of <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of parameter <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The quotients of <code>lhs</code> over each component of <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga62844dd3759063535fb62dd2c2fb11da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; is_vec_component&lt;U&gt;::value, mat&lt;decltype(std::declval&lt;T&gt;) / std::declval&lt;U&gt;)), C, R&gt; &gt; tue::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the quotients of each component of <code>lhs</code> over <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The type of parameter <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>lhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The quotients of each component of <code>lhs</code> over <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8ca0edc97d146e5d7553edc224ae6b10"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype(std::declval&lt;T&gt;) / std::declval&lt;U&gt;)), C, R&gt; tue::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the quotients of each component of <code>lhs</code> over each corresponding component of <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of both <code>lhs</code> and <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The quotients of each component of <code>lhs</code> over each corresponding component of <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5db23838849e6df1e9cb2e0372581ca1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; is_vec_component&lt;T&gt;::value, mat&lt;decltype(std::declval&lt;T&gt;) % std::declval&lt;U&gt;)), C, R&gt; &gt; tue::operator% </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the modulos of <code>lhs</code> over each component of <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The type of parameter <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The modulos of <code>lhs</code> over each component of <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaeb8ddd66598aaea819264addb9441c80"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; is_vec_component&lt;U&gt;::value, mat&lt;decltype(std::declval&lt;T&gt;) % std::declval&lt;U&gt;)), C, R&gt; &gt; tue::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the modulos of each component of <code>lhs</code> over <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The type of parameter <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>lhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The modulos of each component of <code>lhs</code> over <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga532739222ec07d79696eba0d312944c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype(std::declval&lt;T&gt;) % std::declval&lt;U&gt;)), C, R&gt; tue::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the modulos of each component of <code>lhs</code> over each corresponding component of <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of both <code>lhs</code> and <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The modulos of each component of <code>lhs</code> over each corresponding component of <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7cff4234c46b11c2b0c11e50e9358f35"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; is_vec_component&lt;T&gt;::value, mat&lt;decltype(std::declval&lt;T&gt;) &amp; std::declval&lt;U&gt;)), C, R&gt; &gt; tue::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bitwise AND of <code>lhs</code> and each component of <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of parameter <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bitwise AND of <code>lhs</code> and each component of <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga933c909f74b8c6f26630709cc5ee07ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; is_vec_component&lt;U&gt;::value, mat&lt;decltype(std::declval&lt;T&gt;) &amp; std::declval&lt;U&gt;)), C, R&gt; &gt; tue::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bitwise AND of each component of <code>lhs</code> and <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The type of parameter <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>lhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bitwise AND of each component of <code>lhs</code> and <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga076647c106e6fd9cb38ddb0e4d8611f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype(std::declval&lt;T&gt;) &amp; std::declval&lt;U&gt;)), C, R&gt; tue::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bitwise AND of each component of <code>lhs</code> and each corresponding component of <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of both <code>lhs</code> and <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bitwise AND of each component of <code>lhs</code> and each corresponding component of <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga309489790323d76920d10fda7e18b0e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; is_vec_component&lt;T&gt;::value, mat&lt;decltype(std::declval&lt;T&gt;) | std::declval&lt;U&gt;)), C, R&gt; &gt; tue::operator| </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bitwise OR of <code>lhs</code> and each component of <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of parameter <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bitwise OR of <code>lhs</code> and each component of <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8105861f02626e2b42b752eb41a88079"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; is_vec_component&lt;U&gt;::value, mat&lt;decltype(std::declval&lt;T&gt;) | std::declval&lt;U&gt;)), C, R&gt; &gt; tue::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bitwise OR of each component of <code>lhs</code> and <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The type of parameter <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>lhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bitwise OR of each component of <code>lhs</code> and <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf55cd551d4ffb60b5acb1ab29d64e1f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype(std::declval&lt;T&gt;) | std::declval&lt;U&gt;)), C, R&gt; tue::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bitwise OR of each component of <code>lhs</code> and each corresponding component of <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of both <code>lhs</code> and <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bitwise OR of each component of <code>lhs</code> and each corresponding component of <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7347232415c843bfae601f78bf8f5c69"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; is_vec_component&lt;T&gt;::value, mat&lt;decltype(std::declval&lt;T&gt;) ^ std::declval&lt;U&gt;)), C, R&gt; &gt; tue::operator^ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bitwise XOR of <code>lhs</code> and each component of <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of parameter <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bitwise XOR of <code>lhs</code> and each component of <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gacd01f1da79cbd83ba0c5143803f557ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; is_vec_component&lt;U&gt;::value, mat&lt;decltype(std::declval&lt;T&gt;) ^ std::declval&lt;U&gt;)), C, R&gt; &gt; tue::operator^ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bitwise XOR of each component of <code>lhs</code> and <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The type of parameter <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>lhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bitwise XOR of each component of <code>lhs</code> and <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gade0afc7bcf6be71962fe78267235f178"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype(std::declval&lt;T&gt;) ^ std::declval&lt;U&gt;)), C, R&gt; tue::operator^ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bitwise XOR of each component of <code>lhs</code> and each corresponding component of <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of both <code>lhs</code> and <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bitwise XOR of each component of <code>lhs</code> and each corresponding component of <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gab0dce0b786973ab1605aa42a3c464377"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; is_vec_component&lt;T&gt;::value, mat&lt;decltype(std::declval&lt;T&gt;) shift_left std::declval&lt;U&gt;)), C, R&gt; &gt; tue::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bitwise shifts left of <code>lhs</code> by each component of <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of parameter <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bitwise shifts left of <code>lhs</code> by each component of <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9d8f05b8ba308c5e1f34ea44d3d514b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; is_vec_component&lt;U&gt;::value, mat&lt;decltype(std::declval&lt;T&gt;) shift_left std::declval&lt;U&gt;)), C, R&gt; &gt; tue::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bitwise shifts left of each component of <code>lhs</code> by <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The type of parameter <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>lhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bitwise shifts left of each component of <code>lhs</code> by <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa2549949c7896c79cf64712c4239fcda"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype( std::declval&lt;T&gt;) shift_left std::declval&lt;U&gt;)), C, R&gt; tue::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bitwise shifts left of each component of <code>lhs</code> by each corresponding component of <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of both <code>lhs</code> and <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bitwise shifts left of each component of <code>lhs</code> by each corresponding component of <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga288dfc7575c317d12a4fbb83f20a8dff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; is_vec_component&lt;T&gt;::value, mat&lt;decltype(std::declval&lt;T&gt;) shift_right std::declval&lt;U&gt;)), C, R&gt; &gt; tue::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bitwise shifts right of <code>lhs</code> by each component of <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of parameter <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bitwise shifts right of <code>lhs</code> by each component of <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaac98cdf2ac121f5e26021c78b529b0a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; is_vec_component&lt;U&gt;::value, mat&lt;decltype(std::declval&lt;T&gt;) shift_right std::declval&lt;U&gt;)), C, R&gt; &gt; tue::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bitwise shifts right of each component of <code>lhs</code> by <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The type of parameter <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>lhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bitwise shifts right of each component of <code>lhs</code> by <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1235dc009c8267d7eb34ea7aad5d652b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype( std::declval&lt;T&gt;) shift_right std::declval&lt;U&gt;)), C, R&gt; tue::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bitwise shifts right of each component of <code>lhs</code> by each corresponding component of <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of both <code>lhs</code> and <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bitwise shifts right of each component of <code>lhs</code> by each corresponding component of <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga31592c563ba596d54d4c5a0e74492da9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool tue::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether or not two <code>mat</code>'s compare equal. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of both <code>lhs</code> and <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all the corresponding pairs of components compare equal and <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gab98bdf9495d8068da11fdd1d2bcf905b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool tue::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether or not two <code>mat</code>'s compare not equal. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of both <code>lhs</code> and <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if at least one of the corresponding pairs of components compares not equal and <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5f6ae28ba3a684c889d97135251a2a8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mat&lt;T, C, R&gt; tue::math::sin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>tue::math::sin()</code> for each component of <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>m</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>m</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>m</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A <code>mat</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>tue::math::sin()</code> for each component of <code>m</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga58ca317305f155313cbab62f1cab8ddd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mat&lt;T, C, R&gt; tue::math::cos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>tue::math::cos()</code> for each component of <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>m</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>m</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>m</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A <code>mat</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>tue::math::cos()</code> for each component of <code>m</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga14a144006bf050cae7763d80abfcb159"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tue::math::sincos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>sin_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>cos_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>tue::math::sincos()</code> for each component of <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>m</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>m</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>m</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A <code>mat</code>. </td></tr>
    <tr><td class="paramname">sin_out</td><td>A reference to the <code>mat</code> to store the <code>sin()</code> results in. </td></tr>
    <tr><td class="paramname">cos_out</td><td>A reference to the <code>mat</code> to store the <code>cos()</code> results in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacc38cd877f3644db338bd51fa16b3966"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mat&lt;T, C, R&gt; tue::math::exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>tue::math::exp()</code> for each component of <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>m</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>m</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>m</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A <code>mat</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>tue::math::exp()</code> for each component of <code>m</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1e826bd5c7c1296ce0824b257bcfe30d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mat&lt;T, C, R&gt; tue::math::log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>tue::math::log()</code> for each component of <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>m</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>m</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>m</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A <code>mat</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>tue::math::log()</code> for each component of <code>m</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gadf0fa9acb7cbd0cf42c79a515753942a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mat&lt;T, C, R&gt; tue::math::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>tue::math::abs()</code> for each component of <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>m</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>m</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>m</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A <code>mat</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>tue::math::abs()</code> for each component of <code>m</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga254225b7863108d2cef2730afddd1baa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mat&lt;T, C, R&gt; tue::math::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>exponents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>tue::math::pow()</code> for each component of <code>bases</code> and each corresponding component of <code>exponents</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of both <code>bases</code> and <code>exponents</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of both <code>bases</code> and <code>exponents</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of both <code>bases</code> and <code>exponents</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bases</td><td>The bases. </td></tr>
    <tr><td class="paramname">exponents</td><td>The exponents.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>tue::math::pow()</code> for each component of <code>bases</code> and each corresponding component of <code>exponents</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5c4f9ff2bc3638da0909144363d66912"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mat&lt;T, C, R&gt; tue::math::recip </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>tue::math::recip()</code> for each component of <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>m</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>m</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>m</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A <code>mat</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>tue::math::recip()</code> for each component of <code>m</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2728551ee1c66d43ced049f76dd570fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mat&lt;T, C, R&gt; tue::math::sqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>tue::math::sqrt()</code> for each component of <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>m</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>m</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>m</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A <code>mat</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>tue::math::sqrt()</code> for each component of <code>m</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gac007ddc51128fdc36624ec4b24e5c0a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mat&lt;T, C, R&gt; tue::math::rsqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>tue::math::rsqrt()</code> for each component of <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>m</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>m</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>m</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A <code>mat</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>tue::math::rsqrt()</code> for each component of <code>m</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5fc22b68face47b6cb954e14249db350"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mat&lt;T, C, R&gt; tue::math::min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>tue::math::min()</code> for each corresponding pair of components from <code>m1</code> and <code>m2</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of both <code>m1</code> and <code>m2</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of both <code>m1</code> and <code>m2</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of both <code>m1</code> and <code>m2</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>A <code>mat</code>. </td></tr>
    <tr><td class="paramname">m2</td><td>Another <code>mat</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>tue::math::min()</code> for each corresponding pair of components from <code>m1</code> and <code>m2</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2af2897af4ed159329dbe559c6af3b23"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mat&lt;T, C, R&gt; tue::math::max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>tue::math::max()</code> for each corresponding pair of components from <code>m1</code> and <code>m2</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of both <code>m1</code> and <code>m2</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of both <code>m1</code> and <code>m2</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of both <code>m1</code> and <code>m2</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>A <code>mat</code>. </td></tr>
    <tr><td class="paramname">m2</td><td>Another <code>mat</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>tue::math::max()</code> for each corresponding pair of components from <code>m1</code> and <code>m2</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa7d61622d424afd55c5babff0e169a48"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mat&lt;U, C, R&gt; tue::math::mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>conditions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>tue::math::mask()</code> for each corresponding pair of components from <code>conditions</code> and <code>values</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>conditions</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>values</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of both <code>conditions</code> and <code>values</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of both <code>conditions</code> and <code>values</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conditions</td><td>A <code>mat</code>. </td></tr>
    <tr><td class="paramname">values</td><td>Another <code>mat</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>tue::math::mask()</code> for each corresponding pair of components from <code>conditions</code> and <code>values</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5a4dca6290c3689f56dc244878964b1c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mat&lt;U, C, R&gt; tue::math::select </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>conditions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>otherwise</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>tue::math::select()</code> for each corresponding trio of components from <code>conditions</code>, <code>values</code>, and <code>otherwise</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>conditions</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of both <code>values</code> and <code>otherwise</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of all three parameters. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of all three parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conditions</td><td>A <code>mat</code>. </td></tr>
    <tr><td class="paramname">values</td><td>Another <code>mat</code>. </td></tr>
    <tr><td class="paramname">otherwise</td><td>Another <code>mat</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>tue::math::select()</code> for each corresponding trio of components from <code>conditions</code>, <code>values</code>, and <code>otherwise</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga50fcc530e9c5fd072068b4cc3cecfd56"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mat&lt;decltype( tue::math::less(std::declval&lt;T&gt;), std::declval&lt;T&gt;))), C, R&gt; tue::math::less </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>tue::math::less()</code> for each corresponding pair of components from <code>lhs</code> and <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of both <code>lhs</code> and <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>tue::math::less()</code> for each corresponding pair of components from <code>lhs</code> and <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga50fa24240abb35fac25167a2c8fbf517"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mat&lt;decltype( tue::math::less_equal(std::declval&lt;T&gt;), std::declval&lt;T&gt;))), C, R&gt; tue::math::less_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>tue::math::less_equal()</code> for each corresponding pair of components from <code>lhs</code> and <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of both <code>lhs</code> and <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>tue::math::less_equal()</code> for each corresponding pair of components from <code>lhs</code> and <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gadd58f23eb73e050c4f73b8eb1e8e337a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mat&lt;decltype( tue::math::greater(std::declval&lt;T&gt;), std::declval&lt;T&gt;))), C, R&gt; tue::math::greater </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>tue::math::greater()</code> for each corresponding pair of components from <code>lhs</code> and <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of both <code>lhs</code> and <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>tue::math::greater()</code> for each corresponding pair of components from <code>lhs</code> and <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1d252c6d3d29f8d1d5c731e2f540c073"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mat&lt;decltype( tue::math::greater_equal(std::declval&lt;T&gt;), std::declval&lt;T&gt;))), C, R&gt; tue::math::greater_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>tue::math::greater_equal()</code> for each corresponding pair of components from <code>lhs</code> and <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of both <code>lhs</code> and <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>tue::math::greater_equal()</code> for each corresponding pair of components from <code>lhs</code> and <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1731c7c5eed88e40d51d2f44a26bbfe0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mat&lt;decltype( tue::math::equal(std::declval&lt;T&gt;), std::declval&lt;T&gt;))), C, R&gt; tue::math::equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>tue::math::equal()</code> for each corresponding pair of components from <code>lhs</code> and <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of both <code>lhs</code> and <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>tue::math::equal()</code> for each corresponding pair of components from <code>lhs</code> and <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga22e9bbb204c5746bff6e491b507c25d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mat&lt;decltype( tue::math::not_equal(std::declval&lt;T&gt;), std::declval&lt;T&gt;))), C, R&gt; tue::math::not_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>tue::math::not_equal()</code> for each corresponding pair of components from <code>lhs</code> and <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of both <code>lhs</code> and <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>tue::math::not_equal()</code> for each corresponding pair of components from <code>lhs</code> and <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa37f59e665e253f02c579b554cf4ffa2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype( std::declval&lt;T&gt;) * std::declval&lt;U&gt;)), C, R&gt; tue::math::comp_mult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the products of each component of <code>lhs</code> and each corresponding component of <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of both <code>lhs</code> and <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The products of each component of <code>lhs</code> and each corresponding component of <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga17206c5ab12e4aaa5405f76dbf77863a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;T, R, C&gt; tue::math::transpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the transpose of <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>m</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>m</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>m</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A <code>mat</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transpose of <code>m</code>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
