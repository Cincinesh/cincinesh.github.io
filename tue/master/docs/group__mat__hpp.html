<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Tuesday: &lt;tue/mat.hpp&gt;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Tuesday
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">&lt;tue/mat.hpp&gt;</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <code>mat</code> class template and its associated functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:classtue_1_1mat"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat&lt; T, C, R &gt;</a></td></tr>
<tr class="memdesc:classtue_1_1mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2-dimensional matrix.  <a href="group__mat__hpp.html#classtue_1_1mat">More...</a><br /></td></tr>
<tr class="separator:classtue_1_1mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga60a6d444af56a15e792baf8b579e8d92"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga60a6d444af56a15e792baf8b579e8d92"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga60a6d444af56a15e792baf8b579e8d92">tue::mat2x2</a> = mat&lt; T, 2, 2 &gt;</td></tr>
<tr class="memdesc:ga60a6d444af56a15e792baf8b579e8d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2x2 matrix.  <a href="group__mat__hpp.html#ga60a6d444af56a15e792baf8b579e8d92">More...</a><br /></td></tr>
<tr class="separator:ga60a6d444af56a15e792baf8b579e8d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42b45ba8b8b912c26571ae04cf52c066"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga42b45ba8b8b912c26571ae04cf52c066"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga42b45ba8b8b912c26571ae04cf52c066">tue::mat2x3</a> = mat&lt; T, 2, 3 &gt;</td></tr>
<tr class="memdesc:ga42b45ba8b8b912c26571ae04cf52c066"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2x3 matrix.  <a href="group__mat__hpp.html#ga42b45ba8b8b912c26571ae04cf52c066">More...</a><br /></td></tr>
<tr class="separator:ga42b45ba8b8b912c26571ae04cf52c066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga233a373c492e5e9a9d05958b6faf2b29"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga233a373c492e5e9a9d05958b6faf2b29"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga233a373c492e5e9a9d05958b6faf2b29">tue::mat2x4</a> = mat&lt; T, 2, 4 &gt;</td></tr>
<tr class="memdesc:ga233a373c492e5e9a9d05958b6faf2b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2x4 matrix.  <a href="group__mat__hpp.html#ga233a373c492e5e9a9d05958b6faf2b29">More...</a><br /></td></tr>
<tr class="separator:ga233a373c492e5e9a9d05958b6faf2b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1cc493760cbf7f6a39d7b7c3bab406d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa1cc493760cbf7f6a39d7b7c3bab406d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gaa1cc493760cbf7f6a39d7b7c3bab406d">tue::mat3x2</a> = mat&lt; T, 3, 2 &gt;</td></tr>
<tr class="memdesc:gaa1cc493760cbf7f6a39d7b7c3bab406d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3x2 matrix.  <a href="group__mat__hpp.html#gaa1cc493760cbf7f6a39d7b7c3bab406d">More...</a><br /></td></tr>
<tr class="separator:gaa1cc493760cbf7f6a39d7b7c3bab406d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1af37cd6fd67c0bda4030197ce6b985c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1af37cd6fd67c0bda4030197ce6b985c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga1af37cd6fd67c0bda4030197ce6b985c">tue::mat3x3</a> = mat&lt; T, 3, 3 &gt;</td></tr>
<tr class="memdesc:ga1af37cd6fd67c0bda4030197ce6b985c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3x3 matrix.  <a href="group__mat__hpp.html#ga1af37cd6fd67c0bda4030197ce6b985c">More...</a><br /></td></tr>
<tr class="separator:ga1af37cd6fd67c0bda4030197ce6b985c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3233f950e6bac0b09ec2fa6e567a3685"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3233f950e6bac0b09ec2fa6e567a3685"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga3233f950e6bac0b09ec2fa6e567a3685">tue::mat3x4</a> = mat&lt; T, 3, 4 &gt;</td></tr>
<tr class="memdesc:ga3233f950e6bac0b09ec2fa6e567a3685"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3x4 matrix.  <a href="group__mat__hpp.html#ga3233f950e6bac0b09ec2fa6e567a3685">More...</a><br /></td></tr>
<tr class="separator:ga3233f950e6bac0b09ec2fa6e567a3685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e32f544eff5596e4a058422a923bc55"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6e32f544eff5596e4a058422a923bc55"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga6e32f544eff5596e4a058422a923bc55">tue::mat4x2</a> = mat&lt; T, 4, 2 &gt;</td></tr>
<tr class="memdesc:ga6e32f544eff5596e4a058422a923bc55"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 4x2 matrix.  <a href="group__mat__hpp.html#ga6e32f544eff5596e4a058422a923bc55">More...</a><br /></td></tr>
<tr class="separator:ga6e32f544eff5596e4a058422a923bc55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadda0fb2a6ad36b2893014611c9b73e30"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gadda0fb2a6ad36b2893014611c9b73e30"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gadda0fb2a6ad36b2893014611c9b73e30">tue::mat4x3</a> = mat&lt; T, 4, 3 &gt;</td></tr>
<tr class="memdesc:gadda0fb2a6ad36b2893014611c9b73e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 4x3 matrix.  <a href="group__mat__hpp.html#gadda0fb2a6ad36b2893014611c9b73e30">More...</a><br /></td></tr>
<tr class="separator:gadda0fb2a6ad36b2893014611c9b73e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0df1ce73b487ecda5aa0000c8e34eaa8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0df1ce73b487ecda5aa0000c8e34eaa8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga0df1ce73b487ecda5aa0000c8e34eaa8">tue::mat4x4</a> = mat&lt; T, 4, 4 &gt;</td></tr>
<tr class="memdesc:ga0df1ce73b487ecda5aa0000c8e34eaa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 4x4 matrix.  <a href="group__mat__hpp.html#ga0df1ce73b487ecda5aa0000c8e34eaa8">More...</a><br /></td></tr>
<tr class="separator:ga0df1ce73b487ecda5aa0000c8e34eaa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80e533a486177cd40ec5a94bdc361bd1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga80e533a486177cd40ec5a94bdc361bd1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga80e533a486177cd40ec5a94bdc361bd1">tue::fmat2x2</a> = mat2x2&lt; float &gt;</td></tr>
<tr class="memdesc:ga80e533a486177cd40ec5a94bdc361bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2x2 matrix with <code>float</code> components. <br /></td></tr>
<tr class="separator:ga80e533a486177cd40ec5a94bdc361bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab20dd4c9f6458bdbb4f09c55b35c9e9c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab20dd4c9f6458bdbb4f09c55b35c9e9c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gab20dd4c9f6458bdbb4f09c55b35c9e9c">tue::fmat2x3</a> = mat2x3&lt; float &gt;</td></tr>
<tr class="memdesc:gab20dd4c9f6458bdbb4f09c55b35c9e9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2x3 matrix with <code>float</code> components. <br /></td></tr>
<tr class="separator:gab20dd4c9f6458bdbb4f09c55b35c9e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d4d37b9fa3a637d223aaa851cb4aef8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7d4d37b9fa3a637d223aaa851cb4aef8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga7d4d37b9fa3a637d223aaa851cb4aef8">tue::fmat2x4</a> = mat2x4&lt; float &gt;</td></tr>
<tr class="memdesc:ga7d4d37b9fa3a637d223aaa851cb4aef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2x4 matrix with <code>float</code> components. <br /></td></tr>
<tr class="separator:ga7d4d37b9fa3a637d223aaa851cb4aef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf7fa6a602e6074e460b6e79276e31de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabf7fa6a602e6074e460b6e79276e31de"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gabf7fa6a602e6074e460b6e79276e31de">tue::fmat3x2</a> = mat3x2&lt; float &gt;</td></tr>
<tr class="memdesc:gabf7fa6a602e6074e460b6e79276e31de"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3x2 matrix with <code>float</code> components. <br /></td></tr>
<tr class="separator:gabf7fa6a602e6074e460b6e79276e31de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga998dbb4ce3e1871515f28ddd748e5459"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga998dbb4ce3e1871515f28ddd748e5459"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga998dbb4ce3e1871515f28ddd748e5459">tue::fmat3x3</a> = mat3x3&lt; float &gt;</td></tr>
<tr class="memdesc:ga998dbb4ce3e1871515f28ddd748e5459"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3x3 matrix with <code>float</code> components. <br /></td></tr>
<tr class="separator:ga998dbb4ce3e1871515f28ddd748e5459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c3d86c133031648485e9936e22602d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1c3d86c133031648485e9936e22602d8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga1c3d86c133031648485e9936e22602d8">tue::fmat3x4</a> = mat3x4&lt; float &gt;</td></tr>
<tr class="memdesc:ga1c3d86c133031648485e9936e22602d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3x4 matrix with <code>float</code> components. <br /></td></tr>
<tr class="separator:ga1c3d86c133031648485e9936e22602d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9971dc09a5b5872b7c09fec994917b5c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9971dc09a5b5872b7c09fec994917b5c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga9971dc09a5b5872b7c09fec994917b5c">tue::fmat4x2</a> = mat4x2&lt; float &gt;</td></tr>
<tr class="memdesc:ga9971dc09a5b5872b7c09fec994917b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 4x2 matrix with <code>float</code> components. <br /></td></tr>
<tr class="separator:ga9971dc09a5b5872b7c09fec994917b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga840a930e35b20bac78811420befa9826"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga840a930e35b20bac78811420befa9826"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga840a930e35b20bac78811420befa9826">tue::fmat4x3</a> = mat4x3&lt; float &gt;</td></tr>
<tr class="memdesc:ga840a930e35b20bac78811420befa9826"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 4x3 matrix with <code>float</code> components. <br /></td></tr>
<tr class="separator:ga840a930e35b20bac78811420befa9826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae02ecf769302be1069d43a9980c6daa6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae02ecf769302be1069d43a9980c6daa6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gae02ecf769302be1069d43a9980c6daa6">tue::fmat4x4</a> = mat4x4&lt; float &gt;</td></tr>
<tr class="memdesc:gae02ecf769302be1069d43a9980c6daa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 4x4 matrix with <code>float</code> components. <br /></td></tr>
<tr class="separator:gae02ecf769302be1069d43a9980c6daa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b7ecdb3d7b53b4f208886d12d8e123a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5b7ecdb3d7b53b4f208886d12d8e123a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga5b7ecdb3d7b53b4f208886d12d8e123a">tue::dmat2x2</a> = mat2x2&lt; double &gt;</td></tr>
<tr class="memdesc:ga5b7ecdb3d7b53b4f208886d12d8e123a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2x2 matrix with <code>double</code> components. <br /></td></tr>
<tr class="separator:ga5b7ecdb3d7b53b4f208886d12d8e123a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad98f27e588a223a5f3bd2bf90d59871a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad98f27e588a223a5f3bd2bf90d59871a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gad98f27e588a223a5f3bd2bf90d59871a">tue::dmat2x3</a> = mat2x3&lt; double &gt;</td></tr>
<tr class="memdesc:gad98f27e588a223a5f3bd2bf90d59871a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2x3 matrix with <code>double</code> components. <br /></td></tr>
<tr class="separator:gad98f27e588a223a5f3bd2bf90d59871a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga846ad763f3e8078e7e0260596357e527"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga846ad763f3e8078e7e0260596357e527"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga846ad763f3e8078e7e0260596357e527">tue::dmat2x4</a> = mat2x4&lt; double &gt;</td></tr>
<tr class="memdesc:ga846ad763f3e8078e7e0260596357e527"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2x4 matrix with <code>double</code> components. <br /></td></tr>
<tr class="separator:ga846ad763f3e8078e7e0260596357e527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4705444994047a4f9d13fddb54213750"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4705444994047a4f9d13fddb54213750"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga4705444994047a4f9d13fddb54213750">tue::dmat3x2</a> = mat3x2&lt; double &gt;</td></tr>
<tr class="memdesc:ga4705444994047a4f9d13fddb54213750"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3x2 matrix with <code>double</code> components. <br /></td></tr>
<tr class="separator:ga4705444994047a4f9d13fddb54213750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafba906f634cf63e802ffddfb2d3bcd0a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafba906f634cf63e802ffddfb2d3bcd0a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gafba906f634cf63e802ffddfb2d3bcd0a">tue::dmat3x3</a> = mat3x3&lt; double &gt;</td></tr>
<tr class="memdesc:gafba906f634cf63e802ffddfb2d3bcd0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3x3 matrix with <code>double</code> components. <br /></td></tr>
<tr class="separator:gafba906f634cf63e802ffddfb2d3bcd0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbcb9f2be10e2ef2a9b118fb5aa7a079"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacbcb9f2be10e2ef2a9b118fb5aa7a079"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gacbcb9f2be10e2ef2a9b118fb5aa7a079">tue::dmat3x4</a> = mat3x4&lt; double &gt;</td></tr>
<tr class="memdesc:gacbcb9f2be10e2ef2a9b118fb5aa7a079"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3x4 matrix with <code>double</code> components. <br /></td></tr>
<tr class="separator:gacbcb9f2be10e2ef2a9b118fb5aa7a079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00ae9b428d4457cd2e0655b7405e81f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga00ae9b428d4457cd2e0655b7405e81f0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga00ae9b428d4457cd2e0655b7405e81f0">tue::dmat4x2</a> = mat4x2&lt; double &gt;</td></tr>
<tr class="memdesc:ga00ae9b428d4457cd2e0655b7405e81f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 4x2 matrix with <code>double</code> components. <br /></td></tr>
<tr class="separator:ga00ae9b428d4457cd2e0655b7405e81f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c25992cc3db7e4e7b2e5689bbf54990"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8c25992cc3db7e4e7b2e5689bbf54990"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga8c25992cc3db7e4e7b2e5689bbf54990">tue::dmat4x3</a> = mat4x3&lt; double &gt;</td></tr>
<tr class="memdesc:ga8c25992cc3db7e4e7b2e5689bbf54990"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 4x3 matrix with <code>double</code> components. <br /></td></tr>
<tr class="separator:ga8c25992cc3db7e4e7b2e5689bbf54990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69a3b00df771a6da9d5eeaa9037c6383"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga69a3b00df771a6da9d5eeaa9037c6383"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga69a3b00df771a6da9d5eeaa9037c6383">tue::dmat4x4</a> = mat4x4&lt; double &gt;</td></tr>
<tr class="memdesc:ga69a3b00df771a6da9d5eeaa9037c6383"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 4x4 matrix with <code>double</code> components. <br /></td></tr>
<tr class="separator:ga69a3b00df771a6da9d5eeaa9037c6383"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga105c13000f760427fef886850cb232fe"><td class="memTemplParams" colspan="2">template&lt;typename T , int C, int R&gt; </td></tr>
<tr class="memitem:ga105c13000f760427fef886850cb232fe"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(+std::declval&lt; T &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga105c13000f760427fef886850cb232fe">tue::operator+</a> (const mat&lt; T, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:ga105c13000f760427fef886850cb232fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the unary plus of each column of <code>m</code>.  <a href="group__mat__hpp.html#ga105c13000f760427fef886850cb232fe">More...</a><br /></td></tr>
<tr class="separator:ga105c13000f760427fef886850cb232fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28ee4aaf5707d2de51eff8bdc65e99ca"><td class="memTemplParams" colspan="2">template&lt;typename T , int C, int R&gt; </td></tr>
<tr class="memitem:ga28ee4aaf5707d2de51eff8bdc65e99ca"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(-std::declval&lt; T &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga28ee4aaf5707d2de51eff8bdc65e99ca">tue::operator-</a> (const mat&lt; T, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:ga28ee4aaf5707d2de51eff8bdc65e99ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the unary minus of each column of <code>m</code>.  <a href="group__mat__hpp.html#ga28ee4aaf5707d2de51eff8bdc65e99ca">More...</a><br /></td></tr>
<tr class="separator:ga28ee4aaf5707d2de51eff8bdc65e99ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa07d7dace8c23fdb460f29e46f705077"><td class="memTemplParams" colspan="2">template&lt;typename T , int C, int R&gt; </td></tr>
<tr class="memitem:gaa07d7dace8c23fdb460f29e46f705077"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(~std::declval&lt; T &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gaa07d7dace8c23fdb460f29e46f705077">tue::operator~</a> (const mat&lt; T, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:gaa07d7dace8c23fdb460f29e46f705077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bitwise NOT of each column of <code>m</code>.  <a href="group__mat__hpp.html#gaa07d7dace8c23fdb460f29e46f705077">More...</a><br /></td></tr>
<tr class="separator:gaa07d7dace8c23fdb460f29e46f705077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d7b8d39d0a268363cd03b46fda20798"><td class="memTemplParams" colspan="2">template&lt;typename T , int C, int R&gt; </td></tr>
<tr class="memitem:ga7d7b8d39d0a268363cd03b46fda20798"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(!std::declval&lt; T &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga7d7b8d39d0a268363cd03b46fda20798">tue::operator!</a> (const mat&lt; T, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:ga7d7b8d39d0a268363cd03b46fda20798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the logical NOT of each column of <code>m</code>.  <a href="group__mat__hpp.html#ga7d7b8d39d0a268363cd03b46fda20798">More...</a><br /></td></tr>
<tr class="separator:ga7d7b8d39d0a268363cd03b46fda20798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cab1002e95ce96d8891f0de4627829d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga8cab1002e95ce96d8891f0de4627829d"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(std::declval&lt; T &gt;)+std::declval&lt; U &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga8cab1002e95ce96d8891f0de4627829d">tue::operator+</a> (const T &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga8cab1002e95ce96d8891f0de4627829d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sums of <code>lhs</code> and each column of <code>rhs</code>.  <a href="group__mat__hpp.html#ga8cab1002e95ce96d8891f0de4627829d">More...</a><br /></td></tr>
<tr class="separator:ga8cab1002e95ce96d8891f0de4627829d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac76f3a35597e93a7054366218030d02f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:gac76f3a35597e93a7054366218030d02f"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(std::declval&lt; T &gt;)+std::declval&lt; U &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gac76f3a35597e93a7054366218030d02f">tue::operator+</a> (const mat&lt; T, C, R &gt; &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="memdesc:gac76f3a35597e93a7054366218030d02f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sums of each column of <code>lhs</code> and <code>rhs</code>.  <a href="group__mat__hpp.html#gac76f3a35597e93a7054366218030d02f">More...</a><br /></td></tr>
<tr class="separator:gac76f3a35597e93a7054366218030d02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga797da95865c09dbb33905d289aac7d83"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga797da95865c09dbb33905d289aac7d83"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(std::declval&lt; T &gt;)+std::declval&lt; U &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga797da95865c09dbb33905d289aac7d83">tue::operator+</a> (const mat&lt; T, C, R &gt; &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga797da95865c09dbb33905d289aac7d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sums of each column of <code>lhs</code> and each corresponding column of <code>rhs</code>.  <a href="group__mat__hpp.html#ga797da95865c09dbb33905d289aac7d83">More...</a><br /></td></tr>
<tr class="separator:ga797da95865c09dbb33905d289aac7d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93d2bf41f5fed036bc14c735c0e31a9f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga93d2bf41f5fed036bc14c735c0e31a9f"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(std::declval&lt; T &gt;)-std::declval&lt; U &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga93d2bf41f5fed036bc14c735c0e31a9f">tue::operator-</a> (const T &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga93d2bf41f5fed036bc14c735c0e31a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the differences between <code>lhs</code> and each column of <code>rhs</code>.  <a href="group__mat__hpp.html#ga93d2bf41f5fed036bc14c735c0e31a9f">More...</a><br /></td></tr>
<tr class="separator:ga93d2bf41f5fed036bc14c735c0e31a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cd833594a51eff1aca2f488d0d9bbb3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga2cd833594a51eff1aca2f488d0d9bbb3"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(std::declval&lt; T &gt;)-std::declval&lt; U &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga2cd833594a51eff1aca2f488d0d9bbb3">tue::operator-</a> (const mat&lt; T, C, R &gt; &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga2cd833594a51eff1aca2f488d0d9bbb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the differences between each column of <code>lhs</code> and <code>rhs</code>.  <a href="group__mat__hpp.html#ga2cd833594a51eff1aca2f488d0d9bbb3">More...</a><br /></td></tr>
<tr class="separator:ga2cd833594a51eff1aca2f488d0d9bbb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2c8e4f0603a59fa3d6e423ef87b4c2d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:gaa2c8e4f0603a59fa3d6e423ef87b4c2d"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(std::declval&lt; T &gt;)-std::declval&lt; U &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gaa2c8e4f0603a59fa3d6e423ef87b4c2d">tue::operator-</a> (const mat&lt; T, C, R &gt; &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:gaa2c8e4f0603a59fa3d6e423ef87b4c2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the differences between each column of <code>lhs</code> and each corresponding column of <code>rhs</code>.  <a href="group__mat__hpp.html#gaa2c8e4f0603a59fa3d6e423ef87b4c2d">More...</a><br /></td></tr>
<tr class="separator:gaa2c8e4f0603a59fa3d6e423ef87b4c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e4de31b9aa222a3c775327eff004f82"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga5e4de31b9aa222a3c775327eff004f82"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga5e4de31b9aa222a3c775327eff004f82">tue::operator*</a> (const T &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga5e4de31b9aa222a3c775327eff004f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the products of <code>lhs</code> and each column of <code>rhs</code>.  <a href="group__mat__hpp.html#ga5e4de31b9aa222a3c775327eff004f82">More...</a><br /></td></tr>
<tr class="separator:ga5e4de31b9aa222a3c775327eff004f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad34bf6bf898ec2a9876d2b2cee9f535f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:gad34bf6bf898ec2a9876d2b2cee9f535f"><td class="memTemplItemLeft" align="right" valign="top">constexpr vec&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;)), C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gad34bf6bf898ec2a9876d2b2cee9f535f">tue::operator*</a> (const vec&lt; T, R &gt; &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:gad34bf6bf898ec2a9876d2b2cee9f535f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the matrix product of <code>lhs</code> and <code>rhs</code>.  <a href="group__mat__hpp.html#gad34bf6bf898ec2a9876d2b2cee9f535f">More...</a><br /></td></tr>
<tr class="separator:gad34bf6bf898ec2a9876d2b2cee9f535f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85a886a850046ad927e21d590cdeff04"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga85a886a850046ad927e21d590cdeff04"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga85a886a850046ad927e21d590cdeff04">tue::operator*</a> (const mat&lt; T, C, R &gt; &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga85a886a850046ad927e21d590cdeff04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the products of each column of <code>lhs</code> and <code>rhs</code>.  <a href="group__mat__hpp.html#ga85a886a850046ad927e21d590cdeff04">More...</a><br /></td></tr>
<tr class="separator:ga85a886a850046ad927e21d590cdeff04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb7b725c10f654beaf6ac1b4c2e5e739"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:gaeb7b725c10f654beaf6ac1b4c2e5e739"><td class="memTemplItemLeft" align="right" valign="top">constexpr vec&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;)), R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gaeb7b725c10f654beaf6ac1b4c2e5e739">tue::operator*</a> (const mat&lt; T, C, R &gt; &amp;lhs, const vec&lt; U, C &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:gaeb7b725c10f654beaf6ac1b4c2e5e739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the matrix product of <code>lhs</code> and <code>rhs</code>.  <a href="group__mat__hpp.html#gaeb7b725c10f654beaf6ac1b4c2e5e739">More...</a><br /></td></tr>
<tr class="separator:gaeb7b725c10f654beaf6ac1b4c2e5e739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga496433423f8744e525f4aa9a6dadb329"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int N, int R&gt; </td></tr>
<tr class="memitem:ga496433423f8744e525f4aa9a6dadb329"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga496433423f8744e525f4aa9a6dadb329">tue::operator*</a> (const mat&lt; T, N, R &gt; &amp;lhs, const mat&lt; U, C, N &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga496433423f8744e525f4aa9a6dadb329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the matrix product of <code>lhs</code> and <code>rhs</code>.  <a href="group__mat__hpp.html#ga496433423f8744e525f4aa9a6dadb329">More...</a><br /></td></tr>
<tr class="separator:ga496433423f8744e525f4aa9a6dadb329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7a9522d9fa104fde61bd8628589cc00"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:gad7a9522d9fa104fde61bd8628589cc00"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(std::declval&lt; T &gt;)/std::declval&lt; U &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gad7a9522d9fa104fde61bd8628589cc00">tue::operator/</a> (const T &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:gad7a9522d9fa104fde61bd8628589cc00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the quotients of <code>lhs</code> over each column of <code>rhs</code>.  <a href="group__mat__hpp.html#gad7a9522d9fa104fde61bd8628589cc00">More...</a><br /></td></tr>
<tr class="separator:gad7a9522d9fa104fde61bd8628589cc00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac211ba40e222b9b8dcbc429c98c4ebe7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:gac211ba40e222b9b8dcbc429c98c4ebe7"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(std::declval&lt; T &gt;)/std::declval&lt; U &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gac211ba40e222b9b8dcbc429c98c4ebe7">tue::operator/</a> (const mat&lt; T, C, R &gt; &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="memdesc:gac211ba40e222b9b8dcbc429c98c4ebe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the quotients of each column of <code>lhs</code> over <code>rhs</code>.  <a href="group__mat__hpp.html#gac211ba40e222b9b8dcbc429c98c4ebe7">More...</a><br /></td></tr>
<tr class="separator:gac211ba40e222b9b8dcbc429c98c4ebe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ca0edc97d146e5d7553edc224ae6b10"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga8ca0edc97d146e5d7553edc224ae6b10"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(std::declval&lt; T &gt;)/std::declval&lt; U &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga8ca0edc97d146e5d7553edc224ae6b10">tue::operator/</a> (const mat&lt; T, C, R &gt; &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga8ca0edc97d146e5d7553edc224ae6b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the quotients of each column of <code>lhs</code> over each corresponding column of <code>rhs</code>.  <a href="group__mat__hpp.html#ga8ca0edc97d146e5d7553edc224ae6b10">More...</a><br /></td></tr>
<tr class="separator:ga8ca0edc97d146e5d7553edc224ae6b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa84248be4b6871653bee8abd74b7e6d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:gafa84248be4b6871653bee8abd74b7e6d"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(std::declval&lt; T &gt;)%std::declval&lt; U &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gafa84248be4b6871653bee8abd74b7e6d">tue::operator%</a> (const T &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:gafa84248be4b6871653bee8abd74b7e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the modulos of <code>lhs</code> over each column of <code>rhs</code>.  <a href="group__mat__hpp.html#gafa84248be4b6871653bee8abd74b7e6d">More...</a><br /></td></tr>
<tr class="separator:gafa84248be4b6871653bee8abd74b7e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga768566365f3f6389102fea3898756a11"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga768566365f3f6389102fea3898756a11"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(std::declval&lt; T &gt;)%std::declval&lt; U &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga768566365f3f6389102fea3898756a11">tue::operator%</a> (const mat&lt; T, C, R &gt; &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga768566365f3f6389102fea3898756a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the modulos of each column of <code>lhs</code> over <code>rhs</code>.  <a href="group__mat__hpp.html#ga768566365f3f6389102fea3898756a11">More...</a><br /></td></tr>
<tr class="separator:ga768566365f3f6389102fea3898756a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga532739222ec07d79696eba0d312944c3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga532739222ec07d79696eba0d312944c3"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(std::declval&lt; T &gt;)%std::declval&lt; U &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga532739222ec07d79696eba0d312944c3">tue::operator%</a> (const mat&lt; T, C, R &gt; &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga532739222ec07d79696eba0d312944c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the modulos of each column of <code>lhs</code> over each corresponding column of <code>rhs</code>.  <a href="group__mat__hpp.html#ga532739222ec07d79696eba0d312944c3">More...</a><br /></td></tr>
<tr class="separator:ga532739222ec07d79696eba0d312944c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2667c6f80f547ad4bec4f2c8c921d4d8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga2667c6f80f547ad4bec4f2c8c921d4d8"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(std::declval&lt; T &gt;)&amp;std::declval&lt; U &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga2667c6f80f547ad4bec4f2c8c921d4d8">tue::operator&amp;</a> (const T &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga2667c6f80f547ad4bec4f2c8c921d4d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bitwise AND of <code>lhs</code> and each column of <code>rhs</code>.  <a href="group__mat__hpp.html#ga2667c6f80f547ad4bec4f2c8c921d4d8">More...</a><br /></td></tr>
<tr class="separator:ga2667c6f80f547ad4bec4f2c8c921d4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6d5133b97d2c4fd27ff8bc42e595f0a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:gab6d5133b97d2c4fd27ff8bc42e595f0a"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(std::declval&lt; T &gt;)&amp;std::declval&lt; U &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gab6d5133b97d2c4fd27ff8bc42e595f0a">tue::operator&amp;</a> (const mat&lt; T, C, R &gt; &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="memdesc:gab6d5133b97d2c4fd27ff8bc42e595f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bitwise AND of each column of <code>lhs</code> and <code>rhs</code>.  <a href="group__mat__hpp.html#gab6d5133b97d2c4fd27ff8bc42e595f0a">More...</a><br /></td></tr>
<tr class="separator:gab6d5133b97d2c4fd27ff8bc42e595f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga076647c106e6fd9cb38ddb0e4d8611f6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga076647c106e6fd9cb38ddb0e4d8611f6"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(std::declval&lt; T &gt;)&amp;std::declval&lt; U &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga076647c106e6fd9cb38ddb0e4d8611f6">tue::operator&amp;</a> (const mat&lt; T, C, R &gt; &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga076647c106e6fd9cb38ddb0e4d8611f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bitwise AND of each column of <code>lhs</code> and each corresponding column of <code>rhs</code>.  <a href="group__mat__hpp.html#ga076647c106e6fd9cb38ddb0e4d8611f6">More...</a><br /></td></tr>
<tr class="separator:ga076647c106e6fd9cb38ddb0e4d8611f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ac73cccfe3a2c55ce2992e6c454cdf9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga9ac73cccfe3a2c55ce2992e6c454cdf9"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(std::declval&lt; T &gt;)|std::declval&lt; U &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga9ac73cccfe3a2c55ce2992e6c454cdf9">tue::operator|</a> (const T &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga9ac73cccfe3a2c55ce2992e6c454cdf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bitwise OR of <code>lhs</code> and each column of <code>rhs</code>.  <a href="group__mat__hpp.html#ga9ac73cccfe3a2c55ce2992e6c454cdf9">More...</a><br /></td></tr>
<tr class="separator:ga9ac73cccfe3a2c55ce2992e6c454cdf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b54bb1cc08fb19345f30a652ec91843"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga9b54bb1cc08fb19345f30a652ec91843"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(std::declval&lt; T &gt;)|std::declval&lt; U &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga9b54bb1cc08fb19345f30a652ec91843">tue::operator|</a> (const mat&lt; T, C, R &gt; &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga9b54bb1cc08fb19345f30a652ec91843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bitwise OR of each column of <code>lhs</code> and <code>rhs</code>.  <a href="group__mat__hpp.html#ga9b54bb1cc08fb19345f30a652ec91843">More...</a><br /></td></tr>
<tr class="separator:ga9b54bb1cc08fb19345f30a652ec91843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf55cd551d4ffb60b5acb1ab29d64e1f9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:gaf55cd551d4ffb60b5acb1ab29d64e1f9"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(std::declval&lt; T &gt;)|std::declval&lt; U &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gaf55cd551d4ffb60b5acb1ab29d64e1f9">tue::operator|</a> (const mat&lt; T, C, R &gt; &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:gaf55cd551d4ffb60b5acb1ab29d64e1f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bitwise OR of each column of <code>lhs</code> and each corresponding column of <code>rhs</code>.  <a href="group__mat__hpp.html#gaf55cd551d4ffb60b5acb1ab29d64e1f9">More...</a><br /></td></tr>
<tr class="separator:gaf55cd551d4ffb60b5acb1ab29d64e1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74d49d02e2f974ed577b4f899268732e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga74d49d02e2f974ed577b4f899268732e"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(std::declval&lt; T &gt;)^std::declval&lt; U &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga74d49d02e2f974ed577b4f899268732e">tue::operator^</a> (const T &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga74d49d02e2f974ed577b4f899268732e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bitwise XOR of <code>lhs</code> and each column of <code>rhs</code>.  <a href="group__mat__hpp.html#ga74d49d02e2f974ed577b4f899268732e">More...</a><br /></td></tr>
<tr class="separator:ga74d49d02e2f974ed577b4f899268732e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab626587f2316574cf4edff655ab486a1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:gab626587f2316574cf4edff655ab486a1"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(std::declval&lt; T &gt;)^std::declval&lt; U &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gab626587f2316574cf4edff655ab486a1">tue::operator^</a> (const mat&lt; T, C, R &gt; &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="memdesc:gab626587f2316574cf4edff655ab486a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bitwise XOR of each column of <code>lhs</code> and <code>rhs</code>.  <a href="group__mat__hpp.html#gab626587f2316574cf4edff655ab486a1">More...</a><br /></td></tr>
<tr class="separator:gab626587f2316574cf4edff655ab486a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade0afc7bcf6be71962fe78267235f178"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:gade0afc7bcf6be71962fe78267235f178"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(std::declval&lt; T &gt;)^std::declval&lt; U &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gade0afc7bcf6be71962fe78267235f178">tue::operator^</a> (const mat&lt; T, C, R &gt; &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:gade0afc7bcf6be71962fe78267235f178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bitwise XOR of each column of <code>lhs</code> and each corresponding column of <code>rhs</code>.  <a href="group__mat__hpp.html#gade0afc7bcf6be71962fe78267235f178">More...</a><br /></td></tr>
<tr class="separator:gade0afc7bcf6be71962fe78267235f178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb4f82b39dfceefaa6b16c5a72747e52"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:gaeb4f82b39dfceefaa6b16c5a72747e52"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(std::declval&lt; T &gt;) shift_left std::declval&lt; U &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gaeb4f82b39dfceefaa6b16c5a72747e52">tue::operator&lt;&lt;</a> (const T &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:gaeb4f82b39dfceefaa6b16c5a72747e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bitwise shifts left of <code>lhs</code> by each column of <code>rhs</code>.  <a href="group__mat__hpp.html#gaeb4f82b39dfceefaa6b16c5a72747e52">More...</a><br /></td></tr>
<tr class="separator:gaeb4f82b39dfceefaa6b16c5a72747e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3049ee1814dc912e911655f2d7d53064"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga3049ee1814dc912e911655f2d7d53064"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(std::declval&lt; T &gt;) shift_left std::declval&lt; U &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga3049ee1814dc912e911655f2d7d53064">tue::operator&lt;&lt;</a> (const mat&lt; T, C, R &gt; &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga3049ee1814dc912e911655f2d7d53064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bitwise shifts left of each column of <code>lhs</code> by <code>rhs</code>.  <a href="group__mat__hpp.html#ga3049ee1814dc912e911655f2d7d53064">More...</a><br /></td></tr>
<tr class="separator:ga3049ee1814dc912e911655f2d7d53064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2549949c7896c79cf64712c4239fcda"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:gaa2549949c7896c79cf64712c4239fcda"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(std::declval&lt; T &gt;) shift_left std::declval&lt; U &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gaa2549949c7896c79cf64712c4239fcda">tue::operator&lt;&lt;</a> (const mat&lt; T, C, R &gt; &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:gaa2549949c7896c79cf64712c4239fcda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bitwise shifts left of each column of <code>lhs</code> by each corresponding column of <code>rhs</code>.  <a href="group__mat__hpp.html#gaa2549949c7896c79cf64712c4239fcda">More...</a><br /></td></tr>
<tr class="separator:gaa2549949c7896c79cf64712c4239fcda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga884968403e590a3ca8ad37be0dafabb1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga884968403e590a3ca8ad37be0dafabb1"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(std::declval&lt; T &gt;) shift_right std::declval&lt; U &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga884968403e590a3ca8ad37be0dafabb1">tue::operator&gt;&gt;</a> (const T &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga884968403e590a3ca8ad37be0dafabb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bitwise shifts right of <code>lhs</code> by each column of <code>rhs</code>.  <a href="group__mat__hpp.html#ga884968403e590a3ca8ad37be0dafabb1">More...</a><br /></td></tr>
<tr class="separator:ga884968403e590a3ca8ad37be0dafabb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed0137897d3203f9c08016d4b6dd6404"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:gaed0137897d3203f9c08016d4b6dd6404"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(std::declval&lt; T &gt;) shift_right std::declval&lt; U &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gaed0137897d3203f9c08016d4b6dd6404">tue::operator&gt;&gt;</a> (const mat&lt; T, C, R &gt; &amp;lhs, const U &amp;rhs) noexcept</td></tr>
<tr class="memdesc:gaed0137897d3203f9c08016d4b6dd6404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bitwise shifts right of each column of <code>lhs</code> by <code>rhs</code>.  <a href="group__mat__hpp.html#gaed0137897d3203f9c08016d4b6dd6404">More...</a><br /></td></tr>
<tr class="separator:gaed0137897d3203f9c08016d4b6dd6404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1235dc009c8267d7eb34ea7aad5d652b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga1235dc009c8267d7eb34ea7aad5d652b"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(std::declval&lt; T &gt;) shift_right std::declval&lt; U &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga1235dc009c8267d7eb34ea7aad5d652b">tue::operator&gt;&gt;</a> (const mat&lt; T, C, R &gt; &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga1235dc009c8267d7eb34ea7aad5d652b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bitwise shifts right of each column of <code>lhs</code> by each corresponding column of <code>rhs</code>.  <a href="group__mat__hpp.html#ga1235dc009c8267d7eb34ea7aad5d652b">More...</a><br /></td></tr>
<tr class="separator:ga1235dc009c8267d7eb34ea7aad5d652b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31592c563ba596d54d4c5a0e74492da9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga31592c563ba596d54d4c5a0e74492da9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga31592c563ba596d54d4c5a0e74492da9">tue::operator==</a> (const mat&lt; T, C, R &gt; &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga31592c563ba596d54d4c5a0e74492da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not two <code>mat</code>'s compare equal.  <a href="group__mat__hpp.html#ga31592c563ba596d54d4c5a0e74492da9">More...</a><br /></td></tr>
<tr class="separator:ga31592c563ba596d54d4c5a0e74492da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab98bdf9495d8068da11fdd1d2bcf905b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:gab98bdf9495d8068da11fdd1d2bcf905b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gab98bdf9495d8068da11fdd1d2bcf905b">tue::operator!=</a> (const mat&lt; T, C, R &gt; &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:gab98bdf9495d8068da11fdd1d2bcf905b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not two <code>mat</code>'s compare not equal.  <a href="group__mat__hpp.html#gab98bdf9495d8068da11fdd1d2bcf905b">More...</a><br /></td></tr>
<tr class="separator:gab98bdf9495d8068da11fdd1d2bcf905b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga333b4c2ee973302842fcf3ab051b6d5c"><td class="memTemplParams" colspan="2">template&lt;typename T , int C, int R&gt; </td></tr>
<tr class="memitem:ga333b4c2ee973302842fcf3ab051b6d5c"><td class="memTemplItemLeft" align="right" valign="top">mat&lt; decltype(tue::math::sin(std::declval&lt; T &gt;))), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga333b4c2ee973302842fcf3ab051b6d5c">tue::math::sin</a> (const mat&lt; T, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:ga333b4c2ee973302842fcf3ab051b6d5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>tue::math::sin()</code> for each column of <code>m</code>.  <a href="group__mat__hpp.html#ga333b4c2ee973302842fcf3ab051b6d5c">More...</a><br /></td></tr>
<tr class="separator:ga333b4c2ee973302842fcf3ab051b6d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01de421d5c8b70b8c34dde09d2f2aa0e"><td class="memTemplParams" colspan="2">template&lt;typename T , int C, int R&gt; </td></tr>
<tr class="memitem:ga01de421d5c8b70b8c34dde09d2f2aa0e"><td class="memTemplItemLeft" align="right" valign="top">mat&lt; decltype(tue::math::cos(std::declval&lt; T &gt;))), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga01de421d5c8b70b8c34dde09d2f2aa0e">tue::math::cos</a> (const mat&lt; T, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:ga01de421d5c8b70b8c34dde09d2f2aa0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>tue::math::cos()</code> for each column of <code>m</code>.  <a href="group__mat__hpp.html#ga01de421d5c8b70b8c34dde09d2f2aa0e">More...</a><br /></td></tr>
<tr class="separator:ga01de421d5c8b70b8c34dde09d2f2aa0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa605b1024bac63a98fe133ee562bd83b"><td class="memTemplParams" colspan="2">template&lt;typename T , int C, int R&gt; </td></tr>
<tr class="memitem:gaa605b1024bac63a98fe133ee562bd83b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gaa605b1024bac63a98fe133ee562bd83b">tue::math::sincos</a> (const mat&lt; T, C, R &gt; &amp;m, decltype(tue::math::sin(m))&amp;sin_out, decltype(tue::math::sin(m))&amp;cos_out) noexcept</td></tr>
<tr class="memdesc:gaa605b1024bac63a98fe133ee562bd83b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>tue::math::sincos()</code> for each column of <code>m</code>.  <a href="group__mat__hpp.html#gaa605b1024bac63a98fe133ee562bd83b">More...</a><br /></td></tr>
<tr class="separator:gaa605b1024bac63a98fe133ee562bd83b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga909bf1ba4c0d22b7227d949ace7e94d9"><td class="memTemplParams" colspan="2">template&lt;typename T , int C, int R&gt; </td></tr>
<tr class="memitem:ga909bf1ba4c0d22b7227d949ace7e94d9"><td class="memTemplItemLeft" align="right" valign="top">mat&lt; decltype(tue::math::exp(std::declval&lt; T &gt;))), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga909bf1ba4c0d22b7227d949ace7e94d9">tue::math::exp</a> (const mat&lt; T, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:ga909bf1ba4c0d22b7227d949ace7e94d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>tue::math::exp()</code> for each column of <code>m</code>.  <a href="group__mat__hpp.html#ga909bf1ba4c0d22b7227d949ace7e94d9">More...</a><br /></td></tr>
<tr class="separator:ga909bf1ba4c0d22b7227d949ace7e94d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99ede8d5b5b38622a07094f39a05965c"><td class="memTemplParams" colspan="2">template&lt;typename T , int C, int R&gt; </td></tr>
<tr class="memitem:ga99ede8d5b5b38622a07094f39a05965c"><td class="memTemplItemLeft" align="right" valign="top">mat&lt; decltype(tue::math::log(std::declval&lt; T &gt;))), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga99ede8d5b5b38622a07094f39a05965c">tue::math::log</a> (const mat&lt; T, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:ga99ede8d5b5b38622a07094f39a05965c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>tue::math::log()</code> for each column of <code>m</code>.  <a href="group__mat__hpp.html#ga99ede8d5b5b38622a07094f39a05965c">More...</a><br /></td></tr>
<tr class="separator:ga99ede8d5b5b38622a07094f39a05965c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcbdd155662b3a70db96c6271d3e65b0"><td class="memTemplParams" colspan="2">template&lt;typename T , int C, int R&gt; </td></tr>
<tr class="memitem:gadcbdd155662b3a70db96c6271d3e65b0"><td class="memTemplItemLeft" align="right" valign="top">mat&lt; decltype(tue::math::abs(std::declval&lt; T &gt;))), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gadcbdd155662b3a70db96c6271d3e65b0">tue::math::abs</a> (const mat&lt; T, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:gadcbdd155662b3a70db96c6271d3e65b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>tue::math::abs()</code> for each column of <code>m</code>.  <a href="group__mat__hpp.html#gadcbdd155662b3a70db96c6271d3e65b0">More...</a><br /></td></tr>
<tr class="separator:gadcbdd155662b3a70db96c6271d3e65b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bf953bba01e6ec53695ce650217ea24"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga8bf953bba01e6ec53695ce650217ea24"><td class="memTemplItemLeft" align="right" valign="top">mat&lt; decltype(tue::math::pow(std::declval&lt; T &gt;), std::declval&lt; U &gt;))), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga8bf953bba01e6ec53695ce650217ea24">tue::math::pow</a> (const T &amp;base, const mat&lt; U, C, R &gt; &amp;exponents) noexcept</td></tr>
<tr class="memdesc:ga8bf953bba01e6ec53695ce650217ea24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>tue::math::pow()</code> for <code>base</code> and each column of <code>exponents</code>.  <a href="group__mat__hpp.html#ga8bf953bba01e6ec53695ce650217ea24">More...</a><br /></td></tr>
<tr class="separator:ga8bf953bba01e6ec53695ce650217ea24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ba6e779269988a1af37beeb044372fc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga3ba6e779269988a1af37beeb044372fc"><td class="memTemplItemLeft" align="right" valign="top">mat&lt; decltype(tue::math::pow(std::declval&lt; T &gt;), std::declval&lt; U &gt;))), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga3ba6e779269988a1af37beeb044372fc">tue::math::pow</a> (const mat&lt; T, C, R &gt; &amp;bases, const U &amp;exponent) noexcept</td></tr>
<tr class="memdesc:ga3ba6e779269988a1af37beeb044372fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>tue::math::pow()</code> for each column of <code>bases</code> and <code>exponent</code>.  <a href="group__mat__hpp.html#ga3ba6e779269988a1af37beeb044372fc">More...</a><br /></td></tr>
<tr class="separator:ga3ba6e779269988a1af37beeb044372fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98e1b1b3dc55eefafff37540319fdaf2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga98e1b1b3dc55eefafff37540319fdaf2"><td class="memTemplItemLeft" align="right" valign="top">mat&lt; decltype(tue::math::pow(std::declval&lt; T &gt;), std::declval&lt; U &gt;))), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga98e1b1b3dc55eefafff37540319fdaf2">tue::math::pow</a> (const mat&lt; T, C, R &gt; &amp;bases, const mat&lt; U, C, R &gt; &amp;exponents) noexcept</td></tr>
<tr class="memdesc:ga98e1b1b3dc55eefafff37540319fdaf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>tue::math::pow()</code> for each column of <code>bases</code> and each corresponding column of <code>exponents</code>.  <a href="group__mat__hpp.html#ga98e1b1b3dc55eefafff37540319fdaf2">More...</a><br /></td></tr>
<tr class="separator:ga98e1b1b3dc55eefafff37540319fdaf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1deff8b20e3645b4617d4cb404f4ad40"><td class="memTemplParams" colspan="2">template&lt;typename T , int C, int R&gt; </td></tr>
<tr class="memitem:ga1deff8b20e3645b4617d4cb404f4ad40"><td class="memTemplItemLeft" align="right" valign="top">mat&lt; decltype(tue::math::recip(std::declval&lt; T &gt;))), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga1deff8b20e3645b4617d4cb404f4ad40">tue::math::recip</a> (const mat&lt; T, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:ga1deff8b20e3645b4617d4cb404f4ad40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>tue::math::recip()</code> for each column of <code>m</code>.  <a href="group__mat__hpp.html#ga1deff8b20e3645b4617d4cb404f4ad40">More...</a><br /></td></tr>
<tr class="separator:ga1deff8b20e3645b4617d4cb404f4ad40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad690b1d2c29c75bd7429bd83e5ad286e"><td class="memTemplParams" colspan="2">template&lt;typename T , int C, int R&gt; </td></tr>
<tr class="memitem:gad690b1d2c29c75bd7429bd83e5ad286e"><td class="memTemplItemLeft" align="right" valign="top">mat&lt; decltype(tue::math::sqrt(std::declval&lt; T &gt;))), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gad690b1d2c29c75bd7429bd83e5ad286e">tue::math::sqrt</a> (const mat&lt; T, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:gad690b1d2c29c75bd7429bd83e5ad286e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>tue::math::sqrt()</code> for each column of <code>m</code>.  <a href="group__mat__hpp.html#gad690b1d2c29c75bd7429bd83e5ad286e">More...</a><br /></td></tr>
<tr class="separator:gad690b1d2c29c75bd7429bd83e5ad286e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga877010d857778a44dd333a21048cd460"><td class="memTemplParams" colspan="2">template&lt;typename T , int C, int R&gt; </td></tr>
<tr class="memitem:ga877010d857778a44dd333a21048cd460"><td class="memTemplItemLeft" align="right" valign="top">mat&lt; decltype(tue::math::rsqrt(std::declval&lt; T &gt;))), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga877010d857778a44dd333a21048cd460">tue::math::rsqrt</a> (const mat&lt; T, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:ga877010d857778a44dd333a21048cd460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>tue::math::rsqrt()</code> for each column of <code>m</code>.  <a href="group__mat__hpp.html#ga877010d857778a44dd333a21048cd460">More...</a><br /></td></tr>
<tr class="separator:ga877010d857778a44dd333a21048cd460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fc22b68face47b6cb954e14249db350"><td class="memTemplParams" colspan="2">template&lt;typename T , int C, int R&gt; </td></tr>
<tr class="memitem:ga5fc22b68face47b6cb954e14249db350"><td class="memTemplItemLeft" align="right" valign="top">mat&lt; T, C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga5fc22b68face47b6cb954e14249db350">tue::math::min</a> (const mat&lt; T, C, R &gt; &amp;m1, const mat&lt; T, C, R &gt; &amp;m2) noexcept</td></tr>
<tr class="memdesc:ga5fc22b68face47b6cb954e14249db350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>tue::math::min()</code> for each corresponding pair of columns of <code>m1</code> and <code>m2</code>.  <a href="group__mat__hpp.html#ga5fc22b68face47b6cb954e14249db350">More...</a><br /></td></tr>
<tr class="separator:ga5fc22b68face47b6cb954e14249db350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2af2897af4ed159329dbe559c6af3b23"><td class="memTemplParams" colspan="2">template&lt;typename T , int C, int R&gt; </td></tr>
<tr class="memitem:ga2af2897af4ed159329dbe559c6af3b23"><td class="memTemplItemLeft" align="right" valign="top">mat&lt; T, C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga2af2897af4ed159329dbe559c6af3b23">tue::math::max</a> (const mat&lt; T, C, R &gt; &amp;m1, const mat&lt; T, C, R &gt; &amp;m2) noexcept</td></tr>
<tr class="memdesc:ga2af2897af4ed159329dbe559c6af3b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>tue::math::max()</code> for each corresponding pair of columns of <code>m1</code> and <code>m2</code>.  <a href="group__mat__hpp.html#ga2af2897af4ed159329dbe559c6af3b23">More...</a><br /></td></tr>
<tr class="separator:ga2af2897af4ed159329dbe559c6af3b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3894331c6f09ea824628f7e0839348f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:gad3894331c6f09ea824628f7e0839348f"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; U, C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gad3894331c6f09ea824628f7e0839348f">tue::math::select</a> (const mat&lt; T, C, R &gt; &amp;conditions, const mat&lt; U, C, R &gt; &amp;values, const mat&lt; U, C, R &gt; &amp;otherwise=mat&lt; U, C, R &gt;(0)) noexcept</td></tr>
<tr class="memdesc:gad3894331c6f09ea824628f7e0839348f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>tue::math::select()</code> for each corresponding triple of columns from <code>conditions</code>, <code>values</code>, and <code>otherwise</code>.  <a href="group__mat__hpp.html#gad3894331c6f09ea824628f7e0839348f">More...</a><br /></td></tr>
<tr class="separator:gad3894331c6f09ea824628f7e0839348f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92dea19610f3d1df2d2dea0ca313ec7e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga92dea19610f3d1df2d2dea0ca313ec7e"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(tue::math::less(std::declval&lt; T &gt;), std::declval&lt; U &gt;))), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga92dea19610f3d1df2d2dea0ca313ec7e">tue::math::less</a> (const mat&lt; T, C, R &gt; &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga92dea19610f3d1df2d2dea0ca313ec7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>tue::math::less()</code> for each corresponding pair of columns of <code>lhs</code> and <code>rhs</code>.  <a href="group__mat__hpp.html#ga92dea19610f3d1df2d2dea0ca313ec7e">More...</a><br /></td></tr>
<tr class="separator:ga92dea19610f3d1df2d2dea0ca313ec7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3914ebc0fbe28e34e5a9b453dab692e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:gaf3914ebc0fbe28e34e5a9b453dab692e"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(tue::math::less_equal(std::declval&lt; T &gt;), std::declval&lt; U &gt;))), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gaf3914ebc0fbe28e34e5a9b453dab692e">tue::math::less_equal</a> (const mat&lt; T, C, R &gt; &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:gaf3914ebc0fbe28e34e5a9b453dab692e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>tue::math::less_equal()</code> for each corresponding pair of columns of <code>lhs</code> and <code>rhs</code>.  <a href="group__mat__hpp.html#gaf3914ebc0fbe28e34e5a9b453dab692e">More...</a><br /></td></tr>
<tr class="separator:gaf3914ebc0fbe28e34e5a9b453dab692e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab72285dc12f294d45c52d663df572cb5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:gab72285dc12f294d45c52d663df572cb5"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(tue::math::greater(std::declval&lt; T &gt;), std::declval&lt; U &gt;))), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gab72285dc12f294d45c52d663df572cb5">tue::math::greater</a> (const mat&lt; T, C, R &gt; &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:gab72285dc12f294d45c52d663df572cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>tue::math::greater()</code> for each corresponding pair of columns of <code>lhs</code> and <code>rhs</code>.  <a href="group__mat__hpp.html#gab72285dc12f294d45c52d663df572cb5">More...</a><br /></td></tr>
<tr class="separator:gab72285dc12f294d45c52d663df572cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91a94077702069e285df604ea44705a6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga91a94077702069e285df604ea44705a6"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(tue::math::greater_equal(std::declval&lt; T &gt;), std::declval&lt; U &gt;))), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga91a94077702069e285df604ea44705a6">tue::math::greater_equal</a> (const mat&lt; T, C, R &gt; &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga91a94077702069e285df604ea44705a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>tue::math::greater_equal()</code> for each corresponding pair of columns of <code>lhs</code> and <code>rhs</code>.  <a href="group__mat__hpp.html#ga91a94077702069e285df604ea44705a6">More...</a><br /></td></tr>
<tr class="separator:ga91a94077702069e285df604ea44705a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fe3056868bf626f428d08d83b8d7dfb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga1fe3056868bf626f428d08d83b8d7dfb"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(tue::math::equal(std::declval&lt; T &gt;), std::declval&lt; U &gt;))), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga1fe3056868bf626f428d08d83b8d7dfb">tue::math::equal</a> (const mat&lt; T, C, R &gt; &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga1fe3056868bf626f428d08d83b8d7dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>tue::math::equal()</code> for each corresponding pair of columns of <code>lhs</code> and <code>rhs</code>.  <a href="group__mat__hpp.html#ga1fe3056868bf626f428d08d83b8d7dfb">More...</a><br /></td></tr>
<tr class="separator:ga1fe3056868bf626f428d08d83b8d7dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48e9d3aa2820f63eecf4f817d0ca9eed"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:ga48e9d3aa2820f63eecf4f817d0ca9eed"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(tue::math::not_equal(std::declval&lt; T &gt;), std::declval&lt; U &gt;))), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga48e9d3aa2820f63eecf4f817d0ca9eed">tue::math::not_equal</a> (const mat&lt; T, C, R &gt; &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ga48e9d3aa2820f63eecf4f817d0ca9eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>tue::math::not_equal()</code> for each corresponding pair of columns of <code>lhs</code> and <code>rhs</code>.  <a href="group__mat__hpp.html#ga48e9d3aa2820f63eecf4f817d0ca9eed">More...</a><br /></td></tr>
<tr class="separator:ga48e9d3aa2820f63eecf4f817d0ca9eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa37f59e665e253f02c579b554cf4ffa2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int C, int R&gt; </td></tr>
<tr class="memitem:gaa37f59e665e253f02c579b554cf4ffa2"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; decltype(std::declval&lt; T &gt;)*std::declval&lt; U &gt;)), C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#gaa37f59e665e253f02c579b554cf4ffa2">tue::math::comp_mult</a> (const mat&lt; T, C, R &gt; &amp;lhs, const mat&lt; U, C, R &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:gaa37f59e665e253f02c579b554cf4ffa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the products of each column of <code>lhs</code> and each corresponding column of <code>rhs</code>.  <a href="group__mat__hpp.html#gaa37f59e665e253f02c579b554cf4ffa2">More...</a><br /></td></tr>
<tr class="separator:gaa37f59e665e253f02c579b554cf4ffa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17206c5ab12e4aaa5405f76dbf77863a"><td class="memTemplParams" colspan="2">template&lt;typename T , int C, int R&gt; </td></tr>
<tr class="memitem:ga17206c5ab12e4aaa5405f76dbf77863a"><td class="memTemplItemLeft" align="right" valign="top">constexpr mat&lt; T, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ga17206c5ab12e4aaa5405f76dbf77863a">tue::math::transpose</a> (const mat&lt; T, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:ga17206c5ab12e4aaa5405f76dbf77863a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the transpose of <code>m</code>.  <a href="group__mat__hpp.html#ga17206c5ab12e4aaa5405f76dbf77863a">More...</a><br /></td></tr>
<tr class="separator:ga17206c5ab12e4aaa5405f76dbf77863a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The <code>mat</code> class template and its associated functions. </p>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="classtue_1_1mat" id="classtue_1_1mat"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class tue::mat</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T, int C, int R&gt;<br />
class tue::mat&lt; T, C, R &gt;</h3>

<p>A 2-dimensional matrix. </p>
<p><code>mat</code>'s are laid out in column-major order. They have the same size and alignment requirements as <code>vec&lt;T, R&gt;[C]</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type. </td></tr>
    <tr><td class="paramname">C</td><td>The column count. Must be 2, 3, or 4. </td></tr>
    <tr><td class="paramname">R</td><td>The row count. Must be 2, 3, or 4. </td></tr>
  </table>
  </dd>
</dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Types</h3></td></tr>
<tr class="memitem:ac59de3ee035711a062d65524604ac589"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac59de3ee035711a062d65524604ac589"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ac59de3ee035711a062d65524604ac589">component_type</a> = T</td></tr>
<tr class="memdesc:ac59de3ee035711a062d65524604ac589"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <code>mat</code> type's component type. <br /></td></tr>
<tr class="separator:ac59de3ee035711a062d65524604ac589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:ab733634293348ba649a9a35914aff268"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab733634293348ba649a9a35914aff268"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ab733634293348ba649a9a35914aff268">mat</a> () noexcept=default</td></tr>
<tr class="memdesc:ab733634293348ba649a9a35914aff268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructs each component. <br /></td></tr>
<tr class="separator:ab733634293348ba649a9a35914aff268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f46807f349d360ece5885ee5adcf5c"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a95f46807f349d360ece5885ee5adcf5c">mat</a> (const T &amp;x) noexcept</td></tr>
<tr class="memdesc:a95f46807f349d360ece5885ee5adcf5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs each component along the main diagonal with the same value, and all other components with <code>0</code>.  <a href="#a95f46807f349d360ece5885ee5adcf5c">More...</a><br /></td></tr>
<tr class="separator:a95f46807f349d360ece5885ee5adcf5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212aee0ad727c3c67bbffa3c1d503f93"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a212aee0ad727c3c67bbffa3c1d503f93">mat</a> (const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;c0, const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;c1) noexcept</td></tr>
<tr class="memdesc:a212aee0ad727c3c67bbffa3c1d503f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <code>mat</code> with the given columns.  <a href="#a212aee0ad727c3c67bbffa3c1d503f93">More...</a><br /></td></tr>
<tr class="separator:a212aee0ad727c3c67bbffa3c1d503f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0f0b5c4637727dcd51b68907889160"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a2e0f0b5c4637727dcd51b68907889160">mat</a> (const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;c0, const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;c1, const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;c2) noexcept</td></tr>
<tr class="memdesc:a2e0f0b5c4637727dcd51b68907889160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <code>mat</code> with the given columns.  <a href="#a2e0f0b5c4637727dcd51b68907889160">More...</a><br /></td></tr>
<tr class="separator:a2e0f0b5c4637727dcd51b68907889160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4d5d00d5045d0865c171146c5d1389"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a9c4d5d00d5045d0865c171146c5d1389">mat</a> (const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;c0, const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;c1, const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;c2, const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;c3) noexcept</td></tr>
<tr class="memdesc:a9c4d5d00d5045d0865c171146c5d1389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <code>mat</code> with the given columns.  <a href="#a9c4d5d00d5045d0865c171146c5d1389">More...</a><br /></td></tr>
<tr class="separator:a9c4d5d00d5045d0865c171146c5d1389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b51bbaf4500c336f7514c15787645f"><td class="memTemplParams" colspan="2">template&lt;int MR&gt; </td></tr>
<tr class="memitem:ab1b51bbaf4500c336f7514c15787645f"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ab1b51bbaf4500c336f7514c15787645f">mat</a> (const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, 2, MR &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:ab1b51bbaf4500c336f7514c15787645f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly casts another <code>mat</code> to a new size.  <a href="#ab1b51bbaf4500c336f7514c15787645f">More...</a><br /></td></tr>
<tr class="separator:ab1b51bbaf4500c336f7514c15787645f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cfe17212441deba8649c4e3aaa7d751"><td class="memTemplParams" colspan="2">template&lt;int MR&gt; </td></tr>
<tr class="memitem:a7cfe17212441deba8649c4e3aaa7d751"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a7cfe17212441deba8649c4e3aaa7d751">mat</a> (const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, 3, MR &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:a7cfe17212441deba8649c4e3aaa7d751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly casts another <code>mat</code> to a new size.  <a href="#a7cfe17212441deba8649c4e3aaa7d751">More...</a><br /></td></tr>
<tr class="separator:a7cfe17212441deba8649c4e3aaa7d751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3322d04fbe068536fb2c4f9d48efaa1"><td class="memTemplParams" colspan="2">template&lt;int MR&gt; </td></tr>
<tr class="memitem:ae3322d04fbe068536fb2c4f9d48efaa1"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ae3322d04fbe068536fb2c4f9d48efaa1">mat</a> (const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, 4, MR &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:ae3322d04fbe068536fb2c4f9d48efaa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly casts another <code>mat</code> to a new size.  <a href="#ae3322d04fbe068536fb2c4f9d48efaa1">More...</a><br /></td></tr>
<tr class="separator:ae3322d04fbe068536fb2c4f9d48efaa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c1359ba5433401196203f22fc33fc5"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:ac6c1359ba5433401196203f22fc33fc5"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ac6c1359ba5433401196203f22fc33fc5">mat</a> (const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:ac6c1359ba5433401196203f22fc33fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly casts another <code>mat</code> to a new component type.  <a href="#ac6c1359ba5433401196203f22fc33fc5">More...</a><br /></td></tr>
<tr class="separator:ac6c1359ba5433401196203f22fc33fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4e36d7c3615ceedf46fbf7227f30d7"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a6d4e36d7c3615ceedf46fbf7227f30d7"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a6d4e36d7c3615ceedf46fbf7227f30d7">operator mat&lt; U, C, R &gt;</a> () const  noexcept</td></tr>
<tr class="memdesc:a6d4e36d7c3615ceedf46fbf7227f30d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicitly casts this <code>mat</code> to a new component type.  <a href="#a6d4e36d7c3615ceedf46fbf7227f30d7">More...</a><br /></td></tr>
<tr class="separator:a6d4e36d7c3615ceedf46fbf7227f30d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8af6669a032ac2b7b2e59bc93d086b9"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:ac8af6669a032ac2b7b2e59bc93d086b9"><td class="memTemplItemLeft" align="right" valign="top">constexpr const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ac8af6669a032ac2b7b2e59bc93d086b9">operator[]</a> (const I &amp;i) const  noexcept</td></tr>
<tr class="memdesc:ac8af6669a032ac2b7b2e59bc93d086b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the column at the given index.  <a href="#ac8af6669a032ac2b7b2e59bc93d086b9">More...</a><br /></td></tr>
<tr class="separator:ac8af6669a032ac2b7b2e59bc93d086b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72569a23e1168e7fd5b418d911d4213c"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:a72569a23e1168e7fd5b418d911d4213c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a72569a23e1168e7fd5b418d911d4213c">operator[]</a> (const I &amp;i) noexcept</td></tr>
<tr class="memdesc:a72569a23e1168e7fd5b418d911d4213c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the column at the given index.  <a href="#a72569a23e1168e7fd5b418d911d4213c">More...</a><br /></td></tr>
<tr class="separator:a72569a23e1168e7fd5b418d911d4213c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5ab1fc315e949ee99e6d08a619fe19"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a7f5ab1fc315e949ee99e6d08a619fe19">data</a> () const  noexcept</td></tr>
<tr class="memdesc:a7f5ab1fc315e949ee99e6d08a619fe19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to this <code>mat</code>'s underlying component array.  <a href="#a7f5ab1fc315e949ee99e6d08a619fe19">More...</a><br /></td></tr>
<tr class="separator:a7f5ab1fc315e949ee99e6d08a619fe19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7984d48245a53e6a753782ca5c637272"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a7984d48245a53e6a753782ca5c637272">data</a> () noexcept</td></tr>
<tr class="memdesc:a7984d48245a53e6a753782ca5c637272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to this <code>mat</code>'s underlying component array.  <a href="#a7984d48245a53e6a753782ca5c637272">More...</a><br /></td></tr>
<tr class="separator:a7984d48245a53e6a753782ca5c637272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a283acca55758c76109596c9869951243"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a283acca55758c76109596c9869951243">columns</a> () const  noexcept</td></tr>
<tr class="memdesc:a283acca55758c76109596c9869951243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to this <code>mat</code>'s underlying column array.  <a href="#a283acca55758c76109596c9869951243">More...</a><br /></td></tr>
<tr class="separator:a283acca55758c76109596c9869951243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e803f188c46a4fec0307345472e323"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a74e803f188c46a4fec0307345472e323">columns</a> () noexcept</td></tr>
<tr class="memdesc:a74e803f188c46a4fec0307345472e323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to this <code>mat</code>'s underlying column array.  <a href="#a74e803f188c46a4fec0307345472e323">More...</a><br /></td></tr>
<tr class="separator:a74e803f188c46a4fec0307345472e323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193524ed5d0203e01d8a2af82845e6e0"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:a193524ed5d0203e01d8a2af82845e6e0"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a193524ed5d0203e01d8a2af82845e6e0">column</a> (const I &amp;i) const  noexcept</td></tr>
<tr class="memdesc:a193524ed5d0203e01d8a2af82845e6e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the column at the given index.  <a href="#a193524ed5d0203e01d8a2af82845e6e0">More...</a><br /></td></tr>
<tr class="separator:a193524ed5d0203e01d8a2af82845e6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4db9c57fb1b07a97ca699e6b152d1ec"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:ab4db9c57fb1b07a97ca699e6b152d1ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ab4db9c57fb1b07a97ca699e6b152d1ec">set_column</a> (const I &amp;i, const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:ab4db9c57fb1b07a97ca699e6b152d1ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the values of the column at the given index.  <a href="#ab4db9c57fb1b07a97ca699e6b152d1ec">More...</a><br /></td></tr>
<tr class="separator:ab4db9c57fb1b07a97ca699e6b152d1ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19fef97f39f6a96c03070ba1fbdbb391"><td class="memTemplParams" colspan="2">template&lt;typename J &gt; </td></tr>
<tr class="memitem:a19fef97f39f6a96c03070ba1fbdbb391"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a19fef97f39f6a96c03070ba1fbdbb391">row</a> (const J &amp;j) const  noexcept</td></tr>
<tr class="memdesc:a19fef97f39f6a96c03070ba1fbdbb391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the row at the given index.  <a href="#a19fef97f39f6a96c03070ba1fbdbb391">More...</a><br /></td></tr>
<tr class="separator:a19fef97f39f6a96c03070ba1fbdbb391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb077aa62c88189629c6e8dd84a53a2b"><td class="memTemplParams" colspan="2">template&lt;typename J &gt; </td></tr>
<tr class="memitem:afb077aa62c88189629c6e8dd84a53a2b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#afb077aa62c88189629c6e8dd84a53a2b">set_row</a> (const J &amp;j, const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, C &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:afb077aa62c88189629c6e8dd84a53a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the values of the row at the given index.  <a href="#afb077aa62c88189629c6e8dd84a53a2b">More...</a><br /></td></tr>
<tr class="separator:afb077aa62c88189629c6e8dd84a53a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022e2effac766a115d12e70ac4d27567"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a022e2effac766a115d12e70ac4d27567">operator++</a> () noexcept</td></tr>
<tr class="memdesc:a022e2effac766a115d12e70ac4d27567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre-increments each column of this <code>mat</code>.  <a href="#a022e2effac766a115d12e70ac4d27567">More...</a><br /></td></tr>
<tr class="separator:a022e2effac766a115d12e70ac4d27567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d86439ddf6d96be7fd138b0bd04f3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a28d86439ddf6d96be7fd138b0bd04f3b">operator++</a> (int) noexcept</td></tr>
<tr class="memdesc:a28d86439ddf6d96be7fd138b0bd04f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post-increments each column of this <code>mat</code>.  <a href="#a28d86439ddf6d96be7fd138b0bd04f3b">More...</a><br /></td></tr>
<tr class="separator:a28d86439ddf6d96be7fd138b0bd04f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62364eafe8e7610b4dcb7aea7e1e5af3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a62364eafe8e7610b4dcb7aea7e1e5af3">operator--</a> () noexcept</td></tr>
<tr class="memdesc:a62364eafe8e7610b4dcb7aea7e1e5af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre-decrements each column of this <code>mat</code>.  <a href="#a62364eafe8e7610b4dcb7aea7e1e5af3">More...</a><br /></td></tr>
<tr class="separator:a62364eafe8e7610b4dcb7aea7e1e5af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d0a72082f65007dd7cb0ccab5714eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a93d0a72082f65007dd7cb0ccab5714eb">operator--</a> (int) noexcept</td></tr>
<tr class="memdesc:a93d0a72082f65007dd7cb0ccab5714eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post-decrements each column of this <code>mat</code>.  <a href="#a93d0a72082f65007dd7cb0ccab5714eb">More...</a><br /></td></tr>
<tr class="separator:a93d0a72082f65007dd7cb0ccab5714eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe19ebe31d606b5011d84c91228ddee1"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:afe19ebe31d606b5011d84c91228ddee1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#afe19ebe31d606b5011d84c91228ddee1">operator+=</a> (const U &amp;x) noexcept</td></tr>
<tr class="memdesc:afe19ebe31d606b5011d84c91228ddee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds <code>x</code> to each column of this <code>mat</code>.  <a href="#afe19ebe31d606b5011d84c91228ddee1">More...</a><br /></td></tr>
<tr class="separator:afe19ebe31d606b5011d84c91228ddee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc4393f4e76c066018cadc743654009"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:afbc4393f4e76c066018cadc743654009"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#afbc4393f4e76c066018cadc743654009">operator+=</a> (const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:afbc4393f4e76c066018cadc743654009"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds each column of <code>m</code> to the corresponding column of this <code>mat</code>.  <a href="#afbc4393f4e76c066018cadc743654009">More...</a><br /></td></tr>
<tr class="separator:afbc4393f4e76c066018cadc743654009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d939fcedb4290f8a690efd49152731"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a95d939fcedb4290f8a690efd49152731"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a95d939fcedb4290f8a690efd49152731">operator-=</a> (const U &amp;x) noexcept</td></tr>
<tr class="memdesc:a95d939fcedb4290f8a690efd49152731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts <code>x</code> from each column of this <code>mat</code>.  <a href="#a95d939fcedb4290f8a690efd49152731">More...</a><br /></td></tr>
<tr class="separator:a95d939fcedb4290f8a690efd49152731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54769f745dc7fc3f28c39bd605c0eecc"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a54769f745dc7fc3f28c39bd605c0eecc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a54769f745dc7fc3f28c39bd605c0eecc">operator-=</a> (const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:a54769f745dc7fc3f28c39bd605c0eecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts each column of <code>m</code> from the corresponding column of this <code>mat</code>.  <a href="#a54769f745dc7fc3f28c39bd605c0eecc">More...</a><br /></td></tr>
<tr class="separator:a54769f745dc7fc3f28c39bd605c0eecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22010a2ec3a09ccf648854ad6bba092"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:aa22010a2ec3a09ccf648854ad6bba092"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#aa22010a2ec3a09ccf648854ad6bba092">operator*=</a> (const U &amp;x) noexcept</td></tr>
<tr class="memdesc:aa22010a2ec3a09ccf648854ad6bba092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies each column of this <code>mat</code> by <code>x</code>.  <a href="#aa22010a2ec3a09ccf648854ad6bba092">More...</a><br /></td></tr>
<tr class="separator:aa22010a2ec3a09ccf648854ad6bba092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0efbbdd776568b21e01f9a5e0bf23475"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a0efbbdd776568b21e01f9a5e0bf23475"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a0efbbdd776568b21e01f9a5e0bf23475">operator*=</a> (const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, C &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:a0efbbdd776568b21e01f9a5e0bf23475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies this mat by <code>m</code>.  <a href="#a0efbbdd776568b21e01f9a5e0bf23475">More...</a><br /></td></tr>
<tr class="separator:a0efbbdd776568b21e01f9a5e0bf23475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7538921dd0f830de787e4735cfe780db"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a7538921dd0f830de787e4735cfe780db"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a7538921dd0f830de787e4735cfe780db">operator/=</a> (const U &amp;x) noexcept</td></tr>
<tr class="memdesc:a7538921dd0f830de787e4735cfe780db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides each column of this <code>mat</code> by <code>x</code>.  <a href="#a7538921dd0f830de787e4735cfe780db">More...</a><br /></td></tr>
<tr class="separator:a7538921dd0f830de787e4735cfe780db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c74e0e744465a7410a02a383cc49cc"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a07c74e0e744465a7410a02a383cc49cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a07c74e0e744465a7410a02a383cc49cc">operator/=</a> (const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:a07c74e0e744465a7410a02a383cc49cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides each column of this <code>mat</code> by the corresponding column from <code>m</code>.  <a href="#a07c74e0e744465a7410a02a383cc49cc">More...</a><br /></td></tr>
<tr class="separator:a07c74e0e744465a7410a02a383cc49cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c902f3f70f72c555447ecfc60893482"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a5c902f3f70f72c555447ecfc60893482"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a5c902f3f70f72c555447ecfc60893482">operator%=</a> (const U &amp;x) noexcept</td></tr>
<tr class="memdesc:a5c902f3f70f72c555447ecfc60893482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modulos each column of this <code>mat</code> by <code>x</code>.  <a href="#a5c902f3f70f72c555447ecfc60893482">More...</a><br /></td></tr>
<tr class="separator:a5c902f3f70f72c555447ecfc60893482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f77553ed195075427125ab55e624ec"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a15f77553ed195075427125ab55e624ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a15f77553ed195075427125ab55e624ec">operator%=</a> (const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:a15f77553ed195075427125ab55e624ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modulos each column of this <code>mat</code> by the corresponding column from <code>m</code>.  <a href="#a15f77553ed195075427125ab55e624ec">More...</a><br /></td></tr>
<tr class="separator:a15f77553ed195075427125ab55e624ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc00e0fc886b35749316dbb0b5f847be"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:adc00e0fc886b35749316dbb0b5f847be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#adc00e0fc886b35749316dbb0b5f847be">operator&amp;=</a> (const U &amp;x) noexcept</td></tr>
<tr class="memdesc:adc00e0fc886b35749316dbb0b5f847be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise ANDs each column of this <code>mat</code> with <code>x</code>.  <a href="#adc00e0fc886b35749316dbb0b5f847be">More...</a><br /></td></tr>
<tr class="separator:adc00e0fc886b35749316dbb0b5f847be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8aafda72f0ecaac4c5ef57e7ef01113"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:af8aafda72f0ecaac4c5ef57e7ef01113"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#af8aafda72f0ecaac4c5ef57e7ef01113">operator&amp;=</a> (const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:af8aafda72f0ecaac4c5ef57e7ef01113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise ANDs each column of this <code>mat</code> with the corresponding column from <code>m</code>.  <a href="#af8aafda72f0ecaac4c5ef57e7ef01113">More...</a><br /></td></tr>
<tr class="separator:af8aafda72f0ecaac4c5ef57e7ef01113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a149a83688ca4f63610957b5d43ef14af"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a149a83688ca4f63610957b5d43ef14af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a149a83688ca4f63610957b5d43ef14af">operator|=</a> (const U &amp;x) noexcept</td></tr>
<tr class="memdesc:a149a83688ca4f63610957b5d43ef14af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise ORs each column of this <code>mat</code> with <code>x</code>.  <a href="#a149a83688ca4f63610957b5d43ef14af">More...</a><br /></td></tr>
<tr class="separator:a149a83688ca4f63610957b5d43ef14af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19012fac9e03e39514b0ce56a6e5990d"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a19012fac9e03e39514b0ce56a6e5990d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a19012fac9e03e39514b0ce56a6e5990d">operator|=</a> (const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:a19012fac9e03e39514b0ce56a6e5990d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise ORs each column of this <code>mat</code> with the corresponding column from <code>m</code>.  <a href="#a19012fac9e03e39514b0ce56a6e5990d">More...</a><br /></td></tr>
<tr class="separator:a19012fac9e03e39514b0ce56a6e5990d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe9dddf9f5c312862de9a0db03064355"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:afe9dddf9f5c312862de9a0db03064355"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#afe9dddf9f5c312862de9a0db03064355">operator^=</a> (const U &amp;x) noexcept</td></tr>
<tr class="memdesc:afe9dddf9f5c312862de9a0db03064355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise XORs each column of this <code>mat</code> with <code>x</code>.  <a href="#afe9dddf9f5c312862de9a0db03064355">More...</a><br /></td></tr>
<tr class="separator:afe9dddf9f5c312862de9a0db03064355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed5af7a7260f1cc45b65e373c8deb36"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a0ed5af7a7260f1cc45b65e373c8deb36"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a0ed5af7a7260f1cc45b65e373c8deb36">operator^=</a> (const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:a0ed5af7a7260f1cc45b65e373c8deb36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise XORs each column of this <code>mat</code> with the corresponding column from <code>m</code>.  <a href="#a0ed5af7a7260f1cc45b65e373c8deb36">More...</a><br /></td></tr>
<tr class="separator:a0ed5af7a7260f1cc45b65e373c8deb36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9de0453c673691cfe7cf79a3645bf1c"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:af9de0453c673691cfe7cf79a3645bf1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#af9de0453c673691cfe7cf79a3645bf1c">operator&lt;&lt;=</a> (const U &amp;x) noexcept</td></tr>
<tr class="memdesc:af9de0453c673691cfe7cf79a3645bf1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise shifts left each column of this <code>mat</code> by <code>x</code>.  <a href="#af9de0453c673691cfe7cf79a3645bf1c">More...</a><br /></td></tr>
<tr class="separator:af9de0453c673691cfe7cf79a3645bf1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de1d21744fb1cd440e71b581f052c2b"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a6de1d21744fb1cd440e71b581f052c2b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a6de1d21744fb1cd440e71b581f052c2b">operator&lt;&lt;=</a> (const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:a6de1d21744fb1cd440e71b581f052c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise shifts left each column of this <code>mat</code> by the corresponding column from <code>m</code>.  <a href="#a6de1d21744fb1cd440e71b581f052c2b">More...</a><br /></td></tr>
<tr class="separator:a6de1d21744fb1cd440e71b581f052c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af15b154adff6b2e26f0ebd25a1efed31"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:af15b154adff6b2e26f0ebd25a1efed31"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#af15b154adff6b2e26f0ebd25a1efed31">operator&gt;&gt;=</a> (const U &amp;x) noexcept</td></tr>
<tr class="memdesc:af15b154adff6b2e26f0ebd25a1efed31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise shifts right each column of this <code>mat</code> by <code>x</code>.  <a href="#af15b154adff6b2e26f0ebd25a1efed31">More...</a><br /></td></tr>
<tr class="separator:af15b154adff6b2e26f0ebd25a1efed31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbe48ebdfaee578257993a6cd5b2b49"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:afbbe48ebdfaee578257993a6cd5b2b49"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#afbbe48ebdfaee578257993a6cd5b2b49">operator&gt;&gt;=</a> (const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:afbbe48ebdfaee578257993a6cd5b2b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise shifts right each column of this <code>mat</code> by the corresponding column from <code>m</code>.  <a href="#afbbe48ebdfaee578257993a6cd5b2b49">More...</a><br /></td></tr>
<tr class="separator:afbbe48ebdfaee578257993a6cd5b2b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Static Public Member Functions</h3></td></tr>
<tr class="memitem:ac1a5919e6de9cdcb0d281c7aa7f79e30"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:ac1a5919e6de9cdcb0d281c7aa7f79e30"><td class="memTemplItemLeft" align="right" valign="top">static constexpr <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#ac1a5919e6de9cdcb0d281c7aa7f79e30">fill</a> (const U &amp;x) noexcept</td></tr>
<tr class="memdesc:ac1a5919e6de9cdcb0d281c7aa7f79e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code>mat</code> with each column constructed with the same value.  <a href="#ac1a5919e6de9cdcb0d281c7aa7f79e30">More...</a><br /></td></tr>
<tr class="separator:ac1a5919e6de9cdcb0d281c7aa7f79e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed86fdfdc9f5c6bdf1540e5610d363e6"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#aed86fdfdc9f5c6bdf1540e5610d363e6">identity</a> () noexcept</td></tr>
<tr class="memdesc:aed86fdfdc9f5c6bdf1540e5610d363e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code>mat</code> with the main diagonal set to <code>1</code> and all other components set to <code>0</code>.  <a href="#aed86fdfdc9f5c6bdf1540e5610d363e6">More...</a><br /></td></tr>
<tr class="separator:aed86fdfdc9f5c6bdf1540e5610d363e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af99fd2de72a8ca765e84b53f36088a65"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#af99fd2de72a8ca765e84b53f36088a65">zero</a> () noexcept</td></tr>
<tr class="memdesc:af99fd2de72a8ca765e84b53f36088a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code>mat</code> with each component set to <code>0</code>.  <a href="#af99fd2de72a8ca765e84b53f36088a65">More...</a><br /></td></tr>
<tr class="separator:af99fd2de72a8ca765e84b53f36088a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Static Public Attributes</h3></td></tr>
<tr class="memitem:a5eeed6f25114d126e0ba20b7c538382a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5eeed6f25114d126e0ba20b7c538382a"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a5eeed6f25114d126e0ba20b7c538382a">column_count</a> = C</td></tr>
<tr class="memdesc:a5eeed6f25114d126e0ba20b7c538382a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <code>mat</code> type's column count. <br /></td></tr>
<tr class="separator:a5eeed6f25114d126e0ba20b7c538382a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72862d944b914eb5229c8c9f58017585"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72862d944b914eb5229c8c9f58017585"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#a72862d944b914eb5229c8c9f58017585">row_count</a> = R</td></tr>
<tr class="memdesc:a72862d944b914eb5229c8c9f58017585"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <code>mat</code> type's row count. <br /></td></tr>
<tr class="separator:a72862d944b914eb5229c8c9f58017585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5a09135f57c3e531001408bb6e1932"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf5a09135f57c3e531001408bb6e1932"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mat__hpp.html#aaf5a09135f57c3e531001408bb6e1932">component_count</a> = C * R</td></tr>
<tr class="memdesc:aaf5a09135f57c3e531001408bb6e1932"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <code>mat</code> type's component count. <br /></td></tr>
<tr class="separator:aaf5a09135f57c3e531001408bb6e1932"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a class="anchor" id="a95f46807f349d360ece5885ee5adcf5c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::<a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs each component along the main diagonal with the same value, and all other components with <code>0</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to construct the main diagonal with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a212aee0ad727c3c67bbffa3c1d503f93"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::<a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>c1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <code>mat</code> with the given columns. </p>
<p>This overload is only available when <code>C</code> equals <code>2</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c0</td><td>The first column. </td></tr>
    <tr><td class="paramname">c1</td><td>The second column. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2e0f0b5c4637727dcd51b68907889160"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::<a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <code>mat</code> with the given columns. </p>
<p>This overload is only available when <code>C</code> equals <code>3</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c0</td><td>The first column. </td></tr>
    <tr><td class="paramname">c1</td><td>The second column. </td></tr>
    <tr><td class="paramname">c2</td><td>The third column. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9c4d5d00d5045d0865c171146c5d1389"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::<a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>c3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <code>mat</code> with the given columns. </p>
<p>This overload is only available when <code>C</code> equals <code>4</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c0</td><td>The first column. </td></tr>
    <tr><td class="paramname">c1</td><td>The second column. </td></tr>
    <tr><td class="paramname">c2</td><td>The third column. </td></tr>
    <tr><td class="paramname">c3</td><td>The fourth column. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab1b51bbaf4500c336f7514c15787645f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;int MR&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::<a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, 2, MR &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explicitly casts another <code>mat</code> to a new size. </p>
<p>If the new <code>mat</code> is larger than <code>m</code> in either dimension, the new components without corresponding components in <code>m</code> will be constructed with <code>1</code> along the main diagonal and <code>0</code> otherwise. If the new <code>mat</code> is smaller in either dimension, the components from <code>m</code> without corresponding components in the new <code>mat</code> will be ignored.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MR</td><td>The row count of <code>m</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The <code>mat</code> to cast from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7cfe17212441deba8649c4e3aaa7d751"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;int MR&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::<a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, 3, MR &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explicitly casts another <code>mat</code> to a new size. </p>
<p>If the new <code>mat</code> is larger than <code>m</code> in either dimension, the new components without corresponding components in <code>m</code> will be constructed with <code>1</code> along the main diagonal and <code>0</code> otherwise. If the new <code>mat</code> is smaller in either dimension, the components from <code>m</code> without corresponding components in the new <code>mat</code> will be ignored.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MR</td><td>The row count of <code>m</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The <code>mat</code> to cast from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae3322d04fbe068536fb2c4f9d48efaa1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;int MR&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::<a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, 4, MR &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explicitly casts another <code>mat</code> to a new size. </p>
<p>If the new <code>mat</code> is larger than <code>m</code> in either dimension, the new components without corresponding components in <code>m</code> will be constructed with <code>1</code> along the main diagonal and <code>0</code> otherwise. If the new <code>mat</code> is smaller in either dimension, the components from <code>m</code> without corresponding components in the new <code>mat</code> will be ignored.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MR</td><td>The row count of <code>m</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The <code>mat</code> to cast from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac6c1359ba5433401196203f22fc33fc5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::<a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explicitly casts another <code>mat</code> to a new component type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The component type of <code>m</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The <code>mat</code> to cast from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a class="anchor" id="a6d4e36d7c3615ceedf46fbf7227f30d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implicitly casts this <code>mat</code> to a new component type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The new component type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <code>mat</code> with the new component type. </dd></dl>

</div>
</div>
<a class="anchor" id="ac1a5919e6de9cdcb0d281c7aa7f79e30"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <code>mat</code> with each column constructed with the same value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of parameter <code>x</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to construct each column with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>mat</code> with each column constructed with the same value. </dd></dl>

</div>
</div>
<a class="anchor" id="aed86fdfdc9f5c6bdf1540e5610d363e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::identity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <code>mat</code> with the main diagonal set to <code>1</code> and all other components set to <code>0</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>mat</code> with the main diagonal set to <code>1</code> and all other components set to <code>0</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="af99fd2de72a8ca765e84b53f36088a65"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <code>mat</code> with each component set to <code>0</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>mat</code> with each component set to <code>0</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ac8af6669a032ac2b7b2e59bc93d086b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt;T, R&gt;&amp; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const I &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the column at the given index. </p>
<p>No bounds checking is performed. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>The index type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the column at the given index. </dd></dl>

</div>
</div>
<a class="anchor" id="a72569a23e1168e7fd5b418d911d4213c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt;T, R&gt;&amp; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const I &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the column at the given index. </p>
<p>No bounds checking is performed. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>The index type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the column at the given index. </dd></dl>

</div>
</div>
<a class="anchor" id="a7f5ab1fc315e949ee99e6d08a619fe19"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to this <code>mat</code>'s underlying component array. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to this <code>mat</code>'s underlying component array. </dd></dl>

</div>
</div>
<a class="anchor" id="a7984d48245a53e6a753782ca5c637272"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to this <code>mat</code>'s underlying component array. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to this <code>mat</code>'s underlying component array. </dd></dl>

</div>
</div>
<a class="anchor" id="a283acca55758c76109596c9869951243"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt;T, R&gt;* <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::columns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to this <code>mat</code>'s underlying column array. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to this <code>mat</code>'s underlying column array. </dd></dl>

</div>
</div>
<a class="anchor" id="a74e803f188c46a4fec0307345472e323"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt;T, R&gt;* <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::columns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to this <code>mat</code>'s underlying column array. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to this <code>mat</code>'s underlying column array. </dd></dl>

</div>
</div>
<a class="anchor" id="a193524ed5d0203e01d8a2af82845e6e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt;T, R&gt; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::column </td>
          <td>(</td>
          <td class="paramtype">const I &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the column at the given index. </p>
<p>No bounds checking is performed. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>The index type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of the column at the given index. </dd></dl>

</div>
</div>
<a class="anchor" id="ab4db9c57fb1b07a97ca699e6b152d1ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::set_column </td>
          <td>(</td>
          <td class="paramtype">const I &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the values of the column at the given index. </p>
<p>No bounds checking is performed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>The index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index. </td></tr>
    <tr><td class="paramname">v</td><td>The new values for the column. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a19fef97f39f6a96c03070ba1fbdbb391"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename J &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt;T, C&gt; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::row </td>
          <td>(</td>
          <td class="paramtype">const J &amp;&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the row at the given index. </p>
<p>No bounds checking is performed. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">J</td><td>The index type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>The index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of the row at the given index. </dd></dl>

</div>
</div>
<a class="anchor" id="afb077aa62c88189629c6e8dd84a53a2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename J &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::set_row </td>
          <td>(</td>
          <td class="paramtype">const J &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the values of the row at the given index. </p>
<p>No bounds checking is performed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">J</td><td>The index type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>The index. </td></tr>
    <tr><td class="paramname">v</td><td>The new values for the row. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a022e2effac766a115d12e70ac4d27567"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pre-increments each column of this <code>mat</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a28d86439ddf6d96be7fd138b0bd04f3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Post-increments each column of this <code>mat</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A copy of this <code>mat</code> before being incremented. </dd></dl>

</div>
</div>
<a class="anchor" id="a62364eafe8e7610b4dcb7aea7e1e5af3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator-- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pre-decrements each column of this <code>mat</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a93d0a72082f65007dd7cb0ccab5714eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator-- </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Post-decrements each column of this <code>mat</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A copy of this <code>mat</code> before being decremented. </dd></dl>

</div>
</div>
<a class="anchor" id="afe19ebe31d606b5011d84c91228ddee1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds <code>x</code> to each column of this <code>mat</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of parameter <code>x</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to add to each column of this <code>mat</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="afbc4393f4e76c066018cadc743654009"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds each column of <code>m</code> to the corresponding column of this <code>mat</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The component type of <code>m</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The columns to add to each column of this <code>mat</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a95d939fcedb4290f8a690efd49152731"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts <code>x</code> from each column of this <code>mat</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of parameter <code>x</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to subtract from each column of this <code>mat</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a54769f745dc7fc3f28c39bd605c0eecc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts each column of <code>m</code> from the corresponding column of this <code>mat</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The component type of <code>m</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The columns to subtract from each column of this <code>mat</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="aa22010a2ec3a09ccf648854ad6bba092"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies each column of this <code>mat</code> by <code>x</code>. </p>
<p>Note: Unlike <code>mat</code>'s other assignment operators, <code>x</code> cannot be a <code>vec</code> since <code>mat * vec</code> has a special meaning.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of parameter <code>x</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to multiply each column of this <code>mat</code> by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a0efbbdd776568b21e01f9a5e0bf23475"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies this mat by <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The component type of <code>m</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A <code>mat</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a7538921dd0f830de787e4735cfe780db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides each column of this <code>mat</code> by <code>x</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of parameter <code>x</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to divide each column of this <code>mat</code> by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a07c74e0e744465a7410a02a383cc49cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides each column of this <code>mat</code> by the corresponding column from <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The component type of <code>m</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The columns to divide each column of this <code>mat</code> by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a5c902f3f70f72c555447ecfc60893482"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator%= </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modulos each column of this <code>mat</code> by <code>x</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of parameter <code>x</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to modulo each column of this <code>mat</code> by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a15f77553ed195075427125ab55e624ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator%= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modulos each column of this <code>mat</code> by the corresponding column from <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The component type of <code>m</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The columns to modulo each column of this <code>mat</code> by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="adc00e0fc886b35749316dbb0b5f847be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise ANDs each column of this <code>mat</code> with <code>x</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of parameter <code>x</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to bitwise AND each column of this <code>mat</code> with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="af8aafda72f0ecaac4c5ef57e7ef01113"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise ANDs each column of this <code>mat</code> with the corresponding column from <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The component type of <code>m</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The columns to bitwise AND each column of this <code>mat</code> with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a149a83688ca4f63610957b5d43ef14af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator|= </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise ORs each column of this <code>mat</code> with <code>x</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of parameter <code>x</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to bitwise OR each column of this <code>mat</code> with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a19012fac9e03e39514b0ce56a6e5990d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator|= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise ORs each column of this <code>mat</code> with the corresponding column from <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The component type of <code>m</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The columns to bitwise OR each column of this <code>mat</code> with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="afe9dddf9f5c312862de9a0db03064355"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator^= </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise XORs each column of this <code>mat</code> with <code>x</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of parameter <code>x</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to bitwise XOR each column of this <code>mat</code> with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ed5af7a7260f1cc45b65e373c8deb36"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator^= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise XORs each column of this <code>mat</code> with the corresponding column from <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The component type of <code>m</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The columns to bitwise XOR each column of this <code>mat</code> with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="af9de0453c673691cfe7cf79a3645bf1c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator&lt;&lt;= </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise shifts left each column of this <code>mat</code> by <code>x</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of parameter <code>x</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to bitwise shift left each column of this <code>mat</code> by.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a6de1d21744fb1cd440e71b581f052c2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator&lt;&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise shifts left each column of this <code>mat</code> by the corresponding column from <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The component type of <code>m</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The columns to bitwise shift left each column of this <code>mat</code> by.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="af15b154adff6b2e26f0ebd25a1efed31"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator&gt;&gt;= </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise shifts right each column of this <code>mat</code> by <code>x</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The type of parameter <code>x</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to bitwise right left each column of this <code>mat</code> by.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="afbbe48ebdfaee578257993a6cd5b2b49"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int C, int R&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;T, C, R&gt;&amp; <a class="el" href="group__mat__hpp.html#classtue_1_1mat">tue::mat</a>&lt; T, C, R &gt;::operator&gt;&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise shifts right each column of this <code>mat</code> by the corresponding column from <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The component type of <code>m</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The columns to bitwise shift right each column of this <code>mat</code> by.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code>mat</code>. </dd></dl>

</div>
</div>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga60a6d444af56a15e792baf8b579e8d92"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__mat__hpp.html#ga60a6d444af56a15e792baf8b579e8d92">tue::mat2x2</a> = typedef mat&lt;T, 2, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 2x2 matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga42b45ba8b8b912c26571ae04cf52c066"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__mat__hpp.html#ga42b45ba8b8b912c26571ae04cf52c066">tue::mat2x3</a> = typedef mat&lt;T, 2, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 2x3 matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga233a373c492e5e9a9d05958b6faf2b29"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__mat__hpp.html#ga233a373c492e5e9a9d05958b6faf2b29">tue::mat2x4</a> = typedef mat&lt;T, 2, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 2x4 matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa1cc493760cbf7f6a39d7b7c3bab406d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__mat__hpp.html#gaa1cc493760cbf7f6a39d7b7c3bab406d">tue::mat3x2</a> = typedef mat&lt;T, 3, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 3x2 matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1af37cd6fd67c0bda4030197ce6b985c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__mat__hpp.html#ga1af37cd6fd67c0bda4030197ce6b985c">tue::mat3x3</a> = typedef mat&lt;T, 3, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 3x3 matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3233f950e6bac0b09ec2fa6e567a3685"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__mat__hpp.html#ga3233f950e6bac0b09ec2fa6e567a3685">tue::mat3x4</a> = typedef mat&lt;T, 3, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 3x4 matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6e32f544eff5596e4a058422a923bc55"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__mat__hpp.html#ga6e32f544eff5596e4a058422a923bc55">tue::mat4x2</a> = typedef mat&lt;T, 4, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 4x2 matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadda0fb2a6ad36b2893014611c9b73e30"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__mat__hpp.html#gadda0fb2a6ad36b2893014611c9b73e30">tue::mat4x3</a> = typedef mat&lt;T, 4, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 4x3 matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0df1ce73b487ecda5aa0000c8e34eaa8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__mat__hpp.html#ga0df1ce73b487ecda5aa0000c8e34eaa8">tue::mat4x4</a> = typedef mat&lt;T, 4, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 4x4 matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga105c13000f760427fef886850cb232fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype(+std::declval&lt;T&gt;)), C, R&gt; tue::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the unary plus of each column of <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>m</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>m</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>m</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A <code>mat</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unary plus of each column of <code>m</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga28ee4aaf5707d2de51eff8bdc65e99ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype(-std::declval&lt;T&gt;)), C, R&gt; tue::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the unary minus of each column of <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>m</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>m</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>m</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A <code>mat</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unary minus of each column of <code>m</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa07d7dace8c23fdb460f29e46f705077"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype(~std::declval&lt;T&gt;)), C, R&gt; tue::operator~ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bitwise NOT of each column of <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>m</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>m</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>m</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A <code>mat</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bitwise NOT of each column of <code>m</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7d7b8d39d0a268363cd03b46fda20798"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype(!std::declval&lt;T&gt;)), C, R&gt; tue::operator! </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the logical NOT of each column of <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>m</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>m</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>m</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A <code>mat</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The logical NOT of each column of <code>m</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8cab1002e95ce96d8891f0de4627829d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype(std::declval&lt;T&gt;) + std::declval&lt;U&gt;)), C, R&gt; tue::operator+ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sums of <code>lhs</code> and each column of <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of parameter <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sums of <code>lhs</code> and each column of <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gac76f3a35597e93a7054366218030d02f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype(std::declval&lt;T&gt;) + std::declval&lt;U&gt;)), C, R&gt; tue::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sums of each column of <code>lhs</code> and <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The type of parameter <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>lhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sums of each column of <code>lhs</code> and <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga797da95865c09dbb33905d289aac7d83"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype(std::declval&lt;T&gt;) + std::declval&lt;U&gt;)), C, R&gt; tue::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sums of each column of <code>lhs</code> and each corresponding column of <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of both <code>lhs</code> and <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sums of each column of <code>lhs</code> and each corresponding column of <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga93d2bf41f5fed036bc14c735c0e31a9f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype(std::declval&lt;T&gt;) - std::declval&lt;U&gt;)), C, R&gt; tue::operator- </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the differences between <code>lhs</code> and each column of <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of parameter <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The differences between <code>lhs</code> and each column of <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2cd833594a51eff1aca2f488d0d9bbb3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype(std::declval&lt;T&gt;) - std::declval&lt;U&gt;)), C, R&gt; tue::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the differences between each column of <code>lhs</code> and <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The type of parameter <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>lhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The differences between each column of <code>lhs</code> and <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa2c8e4f0603a59fa3d6e423ef87b4c2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype(std::declval&lt;T&gt;) - std::declval&lt;U&gt;)), C, R&gt; tue::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the differences between each column of <code>lhs</code> and each corresponding column of <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of both <code>lhs</code> and <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The differences between each column of <code>lhs</code> and each corresponding column of <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5e4de31b9aa222a3c775327eff004f82"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype(std::declval&lt;T&gt;) * std::declval&lt;U&gt;)), C, R&gt; tue::operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the products of <code>lhs</code> and each column of <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of parameter <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The products of <code>lhs</code> and each column of <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gad34bf6bf898ec2a9876d2b2cee9f535f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr vec&lt;decltype(std::declval&lt;T&gt;) * std::declval&lt;U&gt;)), C&gt; tue::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; T, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the matrix product of <code>lhs</code> and <code>rhs</code>. </p>
<p><code>lhs</code> is treated like a matrix with a single row.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The column count of <code>lhs</code> and row count of <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The matrix product of <code>lhs</code> and <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga85a886a850046ad927e21d590cdeff04"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype(std::declval&lt;T&gt;) * std::declval&lt;U&gt;)), C, R&gt; tue::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the products of each column of <code>lhs</code> and <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The type of parameter <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>lhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The products of each column of <code>lhs</code> and <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaeb7b725c10f654beaf6ac1b4c2e5e739"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr vec&lt;decltype(std::declval&lt;T&gt;) * std::declval&lt;U&gt;)), R&gt; tue::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__vec__hpp.html#classtue_1_1vec">vec</a>&lt; U, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the matrix product of <code>lhs</code> and <code>rhs</code>. </p>
<p><code>rhs</code> is treated like a matrix with a single column.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>lhs</code> and row count of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>lhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The matrix product of <code>lhs</code> and <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga496433423f8744e525f4aa9a6dadb329"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int N, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype(std::declval&lt;T&gt;) * std::declval&lt;U&gt;)), C, R&gt; tue::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, N, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the matrix product of <code>lhs</code> and <code>rhs</code>. </p>
<p>To compute the component-wise product, use <code>tue::math::comp_mult()</code> instead.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of both <code>lhs</code> and <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The matrix product of <code>lhs</code> and <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gad7a9522d9fa104fde61bd8628589cc00"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype(std::declval&lt;T&gt;) / std::declval&lt;U&gt;)), C, R&gt; tue::operator/ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the quotients of <code>lhs</code> over each column of <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of parameter <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The quotients of <code>lhs</code> over each column of <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gac211ba40e222b9b8dcbc429c98c4ebe7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype(std::declval&lt;T&gt;) / std::declval&lt;U&gt;)), C, R&gt; tue::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the quotients of each column of <code>lhs</code> over <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The type of parameter <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>lhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The quotients of each column of <code>lhs</code> over <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8ca0edc97d146e5d7553edc224ae6b10"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype(std::declval&lt;T&gt;) / std::declval&lt;U&gt;)), C, R&gt; tue::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the quotients of each column of <code>lhs</code> over each corresponding column of <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of both <code>lhs</code> and <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The quotients of each column of <code>lhs</code> over each corresponding column of <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gafa84248be4b6871653bee8abd74b7e6d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype(std::declval&lt;T&gt;) % std::declval&lt;U&gt;)), C, R&gt; tue::operator% </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the modulos of <code>lhs</code> over each column of <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The type of parameter <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The modulos of <code>lhs</code> over each column of <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga768566365f3f6389102fea3898756a11"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype(std::declval&lt;T&gt;) % std::declval&lt;U&gt;)), C, R&gt; tue::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the modulos of each column of <code>lhs</code> over <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The type of parameter <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>lhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The modulos of each column of <code>lhs</code> over <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga532739222ec07d79696eba0d312944c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype(std::declval&lt;T&gt;) % std::declval&lt;U&gt;)), C, R&gt; tue::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the modulos of each column of <code>lhs</code> over each corresponding column of <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of both <code>lhs</code> and <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The modulos of each column of <code>lhs</code> over each corresponding column of <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2667c6f80f547ad4bec4f2c8c921d4d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype(std::declval&lt;T&gt;) &amp; std::declval&lt;U&gt;)), C, R&gt; tue::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bitwise AND of <code>lhs</code> and each column of <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of parameter <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bitwise AND of <code>lhs</code> and each column of <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gab6d5133b97d2c4fd27ff8bc42e595f0a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype(std::declval&lt;T&gt;) &amp; std::declval&lt;U&gt;)), C, R&gt; tue::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bitwise AND of each column of <code>lhs</code> and <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The type of parameter <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>lhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bitwise AND of each column of <code>lhs</code> and <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga076647c106e6fd9cb38ddb0e4d8611f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype(std::declval&lt;T&gt;) &amp; std::declval&lt;U&gt;)), C, R&gt; tue::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bitwise AND of each column of <code>lhs</code> and each corresponding column of <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of both <code>lhs</code> and <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bitwise AND of each column of <code>lhs</code> and each corresponding column of <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9ac73cccfe3a2c55ce2992e6c454cdf9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype(std::declval&lt;T&gt;) | std::declval&lt;U&gt;)), C, R&gt; tue::operator| </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bitwise OR of <code>lhs</code> and each column of <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of parameter <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bitwise OR of <code>lhs</code> and each column of <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9b54bb1cc08fb19345f30a652ec91843"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype(std::declval&lt;T&gt;) | std::declval&lt;U&gt;)), C, R&gt; tue::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bitwise OR of each column of <code>lhs</code> and <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The type of parameter <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>lhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bitwise OR of each column of <code>lhs</code> and <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf55cd551d4ffb60b5acb1ab29d64e1f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype(std::declval&lt;T&gt;) | std::declval&lt;U&gt;)), C, R&gt; tue::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bitwise OR of each column of <code>lhs</code> and each corresponding column of <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of both <code>lhs</code> and <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bitwise OR of each column of <code>lhs</code> and each corresponding column of <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga74d49d02e2f974ed577b4f899268732e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype(std::declval&lt;T&gt;) ^ std::declval&lt;U&gt;)), C, R&gt; tue::operator^ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bitwise XOR of <code>lhs</code> and each column of <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of parameter <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bitwise XOR of <code>lhs</code> and each column of <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gab626587f2316574cf4edff655ab486a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype(std::declval&lt;T&gt;) ^ std::declval&lt;U&gt;)), C, R&gt; tue::operator^ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bitwise XOR of each column of <code>lhs</code> and <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The type of parameter <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>lhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bitwise XOR of each column of <code>lhs</code> and <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gade0afc7bcf6be71962fe78267235f178"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype(std::declval&lt;T&gt;) ^ std::declval&lt;U&gt;)), C, R&gt; tue::operator^ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bitwise XOR of each column of <code>lhs</code> and each corresponding column of <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of both <code>lhs</code> and <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bitwise XOR of each column of <code>lhs</code> and each corresponding column of <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaeb4f82b39dfceefaa6b16c5a72747e52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype( std::declval&lt;T&gt;) shift_left std::declval&lt;U&gt;)), C, R&gt; tue::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bitwise shifts left of <code>lhs</code> by each column of <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of parameter <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bitwise shift left of <code>lhs</code> by each column of <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3049ee1814dc912e911655f2d7d53064"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype( std::declval&lt;T&gt;) shift_left std::declval&lt;U&gt;)), C, R&gt; tue::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bitwise shifts left of each column of <code>lhs</code> by <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The type of parameter <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>lhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bitwise shift left of each column of <code>lhs</code> by <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa2549949c7896c79cf64712c4239fcda"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype( std::declval&lt;T&gt;) shift_left std::declval&lt;U&gt;)), C, R&gt; tue::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bitwise shifts left of each column of <code>lhs</code> by each corresponding column of <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of both <code>lhs</code> and <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bitwise shift left of each column of <code>lhs</code> by each corresponding column of <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga884968403e590a3ca8ad37be0dafabb1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype( std::declval&lt;T&gt;) shift_right std::declval&lt;U&gt;)), C, R&gt; tue::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bitwise shifts right of <code>lhs</code> by each column of <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of parameter <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bitwise shift right of <code>lhs</code> by each column of <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaed0137897d3203f9c08016d4b6dd6404"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype( std::declval&lt;T&gt;) shift_right std::declval&lt;U&gt;)), C, R&gt; tue::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bitwise shifts right of each column of <code>lhs</code> by <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The type of parameter <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>lhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bitwise shift right of each column of <code>lhs</code> by <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1235dc009c8267d7eb34ea7aad5d652b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype( std::declval&lt;T&gt;) shift_right std::declval&lt;U&gt;)), C, R&gt; tue::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bitwise shifts right of each column of <code>lhs</code> by each corresponding column of <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of both <code>lhs</code> and <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bitwise shift right of each column of <code>lhs</code> by each corresponding column of <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga31592c563ba596d54d4c5a0e74492da9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool tue::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether or not two <code>mat</code>'s compare equal. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of both <code>lhs</code> and <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all the corresponding pairs of columns compare equal and <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gab98bdf9495d8068da11fdd1d2bcf905b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool tue::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether or not two <code>mat</code>'s compare not equal. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of both <code>lhs</code> and <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if at least one of the corresponding pairs of columns compares not equal and <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga333b4c2ee973302842fcf3ab051b6d5c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mat&lt;decltype(tue::math::sin(std::declval&lt;T&gt;))), C, R&gt; tue::math::sin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>tue::math::sin()</code> for each column of <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>m</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>m</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>m</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A <code>mat</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>tue::math::sin()</code> for each column of <code>m</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga01de421d5c8b70b8c34dde09d2f2aa0e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mat&lt;decltype(tue::math::cos(std::declval&lt;T&gt;))), C, R&gt; tue::math::cos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>tue::math::cos()</code> for each column of <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>m</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>m</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>m</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A <code>mat</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>tue::math::cos()</code> for each column of <code>m</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa605b1024bac63a98fe133ee562bd83b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tue::math::sincos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">decltype(tue::math::sin(m))&amp;&#160;</td>
          <td class="paramname"><em>sin_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">decltype(tue::math::sin(m))&amp;&#160;</td>
          <td class="paramname"><em>cos_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>tue::math::sincos()</code> for each column of <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>m</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>m</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>m</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A <code>mat</code>. </td></tr>
    <tr><td class="paramname">sin_out</td><td>A reference to the <code>mat</code> to store the <code>sin()</code> results in. </td></tr>
    <tr><td class="paramname">cos_out</td><td>A reference to the <code>mat</code> to store the <code>cos()</code> results in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga909bf1ba4c0d22b7227d949ace7e94d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mat&lt;decltype(tue::math::exp(std::declval&lt;T&gt;))), C, R&gt; tue::math::exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>tue::math::exp()</code> for each column of <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>m</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>m</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>m</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A <code>mat</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>tue::math::exp()</code> for each column of <code>m</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga99ede8d5b5b38622a07094f39a05965c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mat&lt;decltype(tue::math::log(std::declval&lt;T&gt;))), C, R&gt; tue::math::log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>tue::math::log()</code> for each column of <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>m</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>m</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>m</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A <code>mat</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>tue::math::log()</code> for each column of <code>m</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gadcbdd155662b3a70db96c6271d3e65b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mat&lt;decltype(tue::math::abs(std::declval&lt;T&gt;))), C, R&gt; tue::math::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>tue::math::abs()</code> for each column of <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>m</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>m</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>m</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A <code>mat</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>tue::math::abs()</code> for each column of <code>m</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8bf953bba01e6ec53695ce650217ea24"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mat&lt;decltype( tue::math::pow(std::declval&lt;T&gt;), std::declval&lt;U&gt;))), C, R&gt; tue::math::pow </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>exponents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>tue::math::pow()</code> for <code>base</code> and each column of <code>exponents</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of parameter <code>base</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>exponents</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>exponents</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>exponents</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base. </td></tr>
    <tr><td class="paramname">exponents</td><td>The exponents.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>tue::math::pow()</code> for <code>base</code> and each column of <code>exponents</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3ba6e779269988a1af37beeb044372fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mat&lt;decltype( tue::math::pow(std::declval&lt;T&gt;), std::declval&lt;U&gt;))), C, R&gt; tue::math::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>exponent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>tue::math::pow()</code> for each column of <code>bases</code> and <code>exponent</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>bases</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The type of parameter <code>exponent</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>bases</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>bases</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bases</td><td>The bases. </td></tr>
    <tr><td class="paramname">exponent</td><td>The exponent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>tue::math::pow()</code> for each column of <code>bases</code> and <code>exponent</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga98e1b1b3dc55eefafff37540319fdaf2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mat&lt;decltype( tue::math::pow(std::declval&lt;T&gt;), std::declval&lt;U&gt;))), C, R&gt; tue::math::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>exponents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>tue::math::pow()</code> for each column of <code>bases</code> and each corresponding column of <code>exponents</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>bases</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>exponents</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>bases</code> and <code>exponents</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>bases</code> and <code>exponents</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bases</td><td>The bases. </td></tr>
    <tr><td class="paramname">exponents</td><td>The exponents.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>tue::math::pow()</code> for each column of <code>bases</code> and each corresponding column of <code>exponents</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1deff8b20e3645b4617d4cb404f4ad40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mat&lt;decltype(tue::math::recip(std::declval&lt;T&gt;))), C, R&gt; tue::math::recip </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>tue::math::recip()</code> for each column of <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>m</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>m</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>m</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A <code>mat</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>tue::math::recip()</code> for each column of <code>m</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gad690b1d2c29c75bd7429bd83e5ad286e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mat&lt;decltype(tue::math::sqrt(std::declval&lt;T&gt;))), C, R&gt; tue::math::sqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>tue::math::sqrt()</code> for each column of <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>m</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>m</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>m</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A <code>mat</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>tue::math::sqrt()</code> for each column of <code>m</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga877010d857778a44dd333a21048cd460"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mat&lt;decltype(tue::math::rsqrt(std::declval&lt;T&gt;))), C, R&gt; tue::math::rsqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>tue::math::rsqrt()</code> for each column of <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>m</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>m</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>m</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A <code>mat</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>tue::math::rsqrt()</code> for each column of <code>m</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5fc22b68face47b6cb954e14249db350"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mat&lt;T, C, R&gt; tue::math::min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>tue::math::min()</code> for each corresponding pair of columns of <code>m1</code> and <code>m2</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>m1</code> and <code>m2</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>m1</code> and <code>m2</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>m1</code> and <code>m2</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>A <code>mat</code>. </td></tr>
    <tr><td class="paramname">m2</td><td>Another <code>mat</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>tue::math::min()</code> for each corresponding pair of columns of <code>m1</code> and <code>m2</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2af2897af4ed159329dbe559c6af3b23"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mat&lt;T, C, R&gt; tue::math::max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>tue::math::max()</code> for each corresponding pair of columns of <code>m1</code> and <code>m2</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>m1</code> and <code>m2</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>m1</code> and <code>m2</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>m1</code> and <code>m2</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>A <code>mat</code>. </td></tr>
    <tr><td class="paramname">m2</td><td>Another <code>mat</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>tue::math::max()</code> for each corresponding pair of columns of <code>m1</code> and <code>m2</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gad3894331c6f09ea824628f7e0839348f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;U, C, R&gt; tue::math::select </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>conditions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>otherwise</em> = <code><a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt;U,&#160;C,&#160;R&gt;(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>tue::math::select()</code> for each corresponding triple of columns from <code>conditions</code>, <code>values</code>, and <code>otherwise</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>conditions</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>values</code> and <code>otherwise</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of all three parameters. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of all three parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conditions</td><td>A <code>mat</code>. </td></tr>
    <tr><td class="paramname">values</td><td>Another <code>mat</code>. </td></tr>
    <tr><td class="paramname">otherwise</td><td>Another <code>mat</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>tue::math::select()</code> for each corresponding triple of columns from <code>conditions</code>, <code>values</code>, and <code>otherwise</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga92dea19610f3d1df2d2dea0ca313ec7e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype( tue::math::less(std::declval&lt;T&gt;), std::declval&lt;U&gt;))), C, R&gt; tue::math::less </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>tue::math::less()</code> for each corresponding pair of columns of <code>lhs</code> and <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of both <code>lhs</code> and <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>tue::math::less()</code> for each corresponding pair of columns of <code>lhs</code> and <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf3914ebc0fbe28e34e5a9b453dab692e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype( tue::math::less_equal(std::declval&lt;T&gt;), std::declval&lt;U&gt;))), C, R&gt; tue::math::less_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>tue::math::less_equal()</code> for each corresponding pair of columns of <code>lhs</code> and <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of both <code>lhs</code> and <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>tue::math::less_equal()</code> for each corresponding pair of columns of <code>lhs</code> and <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gab72285dc12f294d45c52d663df572cb5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype( tue::math::greater(std::declval&lt;T&gt;), std::declval&lt;U&gt;))), C, R&gt; tue::math::greater </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>tue::math::greater()</code> for each corresponding pair of columns of <code>lhs</code> and <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of both <code>lhs</code> and <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>tue::math::greater()</code> for each corresponding pair of columns of <code>lhs</code> and <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga91a94077702069e285df604ea44705a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype( tue::math::greater_equal(std::declval&lt;T&gt;), std::declval&lt;U&gt;))), C, R&gt; tue::math::greater_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>tue::math::greater_equal()</code> for each corresponding pair of columns of <code>lhs</code> and <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of both <code>lhs</code> and <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>tue::math::greater_equal()</code> for each corresponding pair of columns of <code>lhs</code> and <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1fe3056868bf626f428d08d83b8d7dfb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype( tue::math::equal(std::declval&lt;T&gt;), std::declval&lt;U&gt;))), C, R&gt; tue::math::equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>tue::math::equal()</code> for each corresponding pair of columns of <code>lhs</code> and <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of both <code>lhs</code> and <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>tue::math::equal()</code> for each corresponding pair of columns of <code>lhs</code> and <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga48e9d3aa2820f63eecf4f817d0ca9eed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype( tue::math::not_equal(std::declval&lt;T&gt;), std::declval&lt;U&gt;))), C, R&gt; tue::math::not_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>tue::math::not_equal()</code> for each corresponding pair of columns of <code>lhs</code> and <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of both <code>lhs</code> and <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>tue::math::not_equal()</code> for each corresponding pair of columns of <code>lhs</code> and <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa37f59e665e253f02c579b554cf4ffa2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;decltype( std::declval&lt;T&gt;) * std::declval&lt;U&gt;)), C, R&gt; tue::math::comp_mult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; U, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the products of each column of <code>lhs</code> and each corresponding column of <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>lhs</code>. </td></tr>
    <tr><td class="paramname">U</td><td>The component type of <code>rhs</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of both <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of both <code>lhs</code> and <code>rhs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The products of each column of <code>lhs</code> and each corresponding column of <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga17206c5ab12e4aaa5405f76dbf77863a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C, int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mat&lt;T, R, C&gt; tue::math::transpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__mat__hpp.html#classtue_1_1mat">mat</a>&lt; T, C, R &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the transpose of <code>m</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>m</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of <code>m</code>. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of <code>m</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A <code>mat</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transpose of <code>m</code>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
