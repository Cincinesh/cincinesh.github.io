<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Tuesday: &lt;tue/transform.hpp&gt;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Tuesday
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">&lt;tue/transform.hpp&gt;</div>  </div>
</div><!--header-->
<div class="contents">

<p>Functions for generating and converting between different types of transformations.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaaaeee74666e22dae8f8edc57d85b06d1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaaaeee74666e22dae8f8edc57d85b06d1"><td class="memTemplItemLeft" align="right" valign="top">vec4&lt; decltype(tue::math::sin(std::declval&lt; T &gt;)))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transform__hpp.html#gaaaeee74666e22dae8f8edc57d85b06d1">tue::transform::axis_angle</a> (const T &amp;x, const T &amp;y, const T &amp;z) noexcept</td></tr>
<tr class="memdesc:gaaaeee74666e22dae8f8edc57d85b06d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a rotation vector to an axis-angle vector.  <a href="group__transform__hpp.html#gaaaeee74666e22dae8f8edc57d85b06d1">More...</a><br /></td></tr>
<tr class="separator:gaaaeee74666e22dae8f8edc57d85b06d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4101d9cd158d7bbf2825b35e96af0dc7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4101d9cd158d7bbf2825b35e96af0dc7"><td class="memTemplItemLeft" align="right" valign="top">vec4&lt; decltype(tue::math::sin(std::declval&lt; T &gt;)))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transform__hpp.html#ga4101d9cd158d7bbf2825b35e96af0dc7">tue::transform::axis_angle</a> (const vec3&lt; T &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:ga4101d9cd158d7bbf2825b35e96af0dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a rotation vector to an axis-angle vector.  <a href="group__transform__hpp.html#ga4101d9cd158d7bbf2825b35e96af0dc7">More...</a><br /></td></tr>
<tr class="separator:ga4101d9cd158d7bbf2825b35e96af0dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76346bf69314c2738dbec8ff9ad95876"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga76346bf69314c2738dbec8ff9ad95876"><td class="memTemplItemLeft" align="right" valign="top">constexpr vec3&lt; decltype(tue::math::sin(std::declval&lt; T &gt;)))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transform__hpp.html#ga76346bf69314c2738dbec8ff9ad95876">tue::transform::rotation_vec</a> (const T &amp;axis_x, const T &amp;axis_y, const T &amp;axis_z, const T &amp;angle) noexcept</td></tr>
<tr class="memdesc:ga76346bf69314c2738dbec8ff9ad95876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an axis-angle pair to a rotation vector.  <a href="group__transform__hpp.html#ga76346bf69314c2738dbec8ff9ad95876">More...</a><br /></td></tr>
<tr class="separator:ga76346bf69314c2738dbec8ff9ad95876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb509e89b7ab371f00dd00fd29c5bbe2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gacb509e89b7ab371f00dd00fd29c5bbe2"><td class="memTemplItemLeft" align="right" valign="top">constexpr vec3&lt; decltype(tue::math::sin(std::declval&lt; T &gt;)))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transform__hpp.html#gacb509e89b7ab371f00dd00fd29c5bbe2">tue::transform::rotation_vec</a> (const vec3&lt; T &gt; &amp;axis, const T &amp;angle) noexcept</td></tr>
<tr class="memdesc:gacb509e89b7ab371f00dd00fd29c5bbe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an axis-angle pair to a rotation vector.  <a href="group__transform__hpp.html#gacb509e89b7ab371f00dd00fd29c5bbe2">More...</a><br /></td></tr>
<tr class="separator:gacb509e89b7ab371f00dd00fd29c5bbe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e66bb337a01361380b7624572981e90"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5e66bb337a01361380b7624572981e90"><td class="memTemplItemLeft" align="right" valign="top">constexpr vec3&lt; decltype(tue::math::sin(std::declval&lt; T &gt;)))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transform__hpp.html#ga5e66bb337a01361380b7624572981e90">tue::transform::rotation_vec</a> (const vec4&lt; T &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:ga5e66bb337a01361380b7624572981e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an axis-angle vector to a rotation vector.  <a href="group__transform__hpp.html#ga5e66bb337a01361380b7624572981e90">More...</a><br /></td></tr>
<tr class="separator:ga5e66bb337a01361380b7624572981e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga970795f77a70055a622b13b56c51dfc3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga970795f77a70055a622b13b56c51dfc3"><td class="memTemplItemLeft" align="right" valign="top">quat&lt; decltype(tue::math::sin(std::declval&lt; T &gt;)))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transform__hpp.html#ga970795f77a70055a622b13b56c51dfc3">tue::transform::rotation_quat</a> (const T &amp;axis_x, const T &amp;axis_y, const T &amp;axis_z, const T &amp;angle) noexcept</td></tr>
<tr class="memdesc:ga970795f77a70055a622b13b56c51dfc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an axis-angle pair to a rotation quaternion.  <a href="group__transform__hpp.html#ga970795f77a70055a622b13b56c51dfc3">More...</a><br /></td></tr>
<tr class="separator:ga970795f77a70055a622b13b56c51dfc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53a0ca88778f7e890943f0446b3b0775"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga53a0ca88778f7e890943f0446b3b0775"><td class="memTemplItemLeft" align="right" valign="top">quat&lt; decltype(tue::math::sin(std::declval&lt; T &gt;)))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transform__hpp.html#ga53a0ca88778f7e890943f0446b3b0775">tue::transform::rotation_quat</a> (const vec3&lt; T &gt; &amp;axis, const T &amp;angle) noexcept</td></tr>
<tr class="memdesc:ga53a0ca88778f7e890943f0446b3b0775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an axis-angle pair to a rotation quaternion.  <a href="group__transform__hpp.html#ga53a0ca88778f7e890943f0446b3b0775">More...</a><br /></td></tr>
<tr class="separator:ga53a0ca88778f7e890943f0446b3b0775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebc4f2ca548da112a66c95900782b34f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaebc4f2ca548da112a66c95900782b34f"><td class="memTemplItemLeft" align="right" valign="top">quat&lt; decltype(tue::math::sin(std::declval&lt; T &gt;)))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transform__hpp.html#gaebc4f2ca548da112a66c95900782b34f">tue::transform::rotation_quat</a> (const vec4&lt; T &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:gaebc4f2ca548da112a66c95900782b34f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an axis-angle vector to a rotation quaternion.  <a href="group__transform__hpp.html#gaebc4f2ca548da112a66c95900782b34f">More...</a><br /></td></tr>
<tr class="separator:gaebc4f2ca548da112a66c95900782b34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7083407cef189d08696f231f10550cb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab7083407cef189d08696f231f10550cb"><td class="memTemplItemLeft" align="right" valign="top">quat&lt; decltype(tue::math::sin(std::declval&lt; T &gt;)))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transform__hpp.html#gab7083407cef189d08696f231f10550cb">tue::transform::rotation_quat</a> (const T &amp;x, const T &amp;y, const T &amp;z) noexcept</td></tr>
<tr class="memdesc:gab7083407cef189d08696f231f10550cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a rotation vector to a rotation quaternion.  <a href="group__transform__hpp.html#gab7083407cef189d08696f231f10550cb">More...</a><br /></td></tr>
<tr class="separator:gab7083407cef189d08696f231f10550cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6b907a1c8c6b85eb30b52ef4dd39111"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab6b907a1c8c6b85eb30b52ef4dd39111"><td class="memTemplItemLeft" align="right" valign="top">quat&lt; decltype(tue::math::sin(std::declval&lt; T &gt;)))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transform__hpp.html#gab6b907a1c8c6b85eb30b52ef4dd39111">tue::transform::rotation_quat</a> (const vec3&lt; T &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:gab6b907a1c8c6b85eb30b52ef4dd39111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a rotation vector to a rotation quaternion.  <a href="group__transform__hpp.html#gab6b907a1c8c6b85eb30b52ef4dd39111">More...</a><br /></td></tr>
<tr class="separator:gab6b907a1c8c6b85eb30b52ef4dd39111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d3943ce101ed529e49f3fad0825a899"><td class="memTemplParams" colspan="2">template&lt;typename T , int C = 4, int R = 4&gt; </td></tr>
<tr class="memitem:ga2d3943ce101ed529e49f3fad0825a899"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt;(C &gt;=2 &amp;&amp;R &gt;=3), mat&lt; T, C, R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transform__hpp.html#ga2d3943ce101ed529e49f3fad0825a899">tue::transform::translation_mat</a> (const T &amp;x, const T &amp;y) noexcept</td></tr>
<tr class="memdesc:ga2d3943ce101ed529e49f3fad0825a899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a 2D translation matrix.  <a href="group__transform__hpp.html#ga2d3943ce101ed529e49f3fad0825a899">More...</a><br /></td></tr>
<tr class="separator:ga2d3943ce101ed529e49f3fad0825a899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32837254e36f0c78faea90d8ef4a7d68"><td class="memTemplParams" colspan="2">template&lt;typename T , int C = 4, int R = 4&gt; </td></tr>
<tr class="memitem:ga32837254e36f0c78faea90d8ef4a7d68"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt;(C &gt;=2 &amp;&amp;R &gt;=3), mat&lt; T, C, R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transform__hpp.html#ga32837254e36f0c78faea90d8ef4a7d68">tue::transform::translation_mat</a> (const vec2&lt; T &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:ga32837254e36f0c78faea90d8ef4a7d68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a 2D translation matrix.  <a href="group__transform__hpp.html#ga32837254e36f0c78faea90d8ef4a7d68">More...</a><br /></td></tr>
<tr class="separator:ga32837254e36f0c78faea90d8ef4a7d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7e7e1fa5d789fd2614b0d97723cdd98"><td class="memTemplParams" colspan="2">template&lt;typename T , int C = 4, int R = 4&gt; </td></tr>
<tr class="memitem:gaa7e7e1fa5d789fd2614b0d97723cdd98"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt;(C &gt;=3 &amp;&amp;R &gt;=4), mat&lt; T, C, R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transform__hpp.html#gaa7e7e1fa5d789fd2614b0d97723cdd98">tue::transform::translation_mat</a> (const T &amp;x, const T &amp;y, const T &amp;z) noexcept</td></tr>
<tr class="memdesc:gaa7e7e1fa5d789fd2614b0d97723cdd98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a 3D translation matrix.  <a href="group__transform__hpp.html#gaa7e7e1fa5d789fd2614b0d97723cdd98">More...</a><br /></td></tr>
<tr class="separator:gaa7e7e1fa5d789fd2614b0d97723cdd98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8213130d102ec03b76e4981a0410fc45"><td class="memTemplParams" colspan="2">template&lt;typename T , int C = 4, int R = 4&gt; </td></tr>
<tr class="memitem:ga8213130d102ec03b76e4981a0410fc45"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt;(C &gt;=3 &amp;&amp;R &gt;=4), mat&lt; T, C, R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transform__hpp.html#ga8213130d102ec03b76e4981a0410fc45">tue::transform::translation_mat</a> (const vec3&lt; T &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:ga8213130d102ec03b76e4981a0410fc45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a 3D translation matrix.  <a href="group__transform__hpp.html#ga8213130d102ec03b76e4981a0410fc45">More...</a><br /></td></tr>
<tr class="separator:ga8213130d102ec03b76e4981a0410fc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e99a4eb84ba46e36bf35fc6ee3a769e"><td class="memTemplParams" colspan="2">template&lt;typename T , int C = 4, int R = 4&gt; </td></tr>
<tr class="memitem:ga5e99a4eb84ba46e36bf35fc6ee3a769e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;(C &gt;=2 &amp;&amp;R &gt;=2), mat&lt; decltype(tue::math::sin(std::declval&lt; T &gt;))), C, R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transform__hpp.html#ga5e99a4eb84ba46e36bf35fc6ee3a769e">tue::transform::rotation_mat</a> (const T &amp;angle) noexcept</td></tr>
<tr class="memdesc:ga5e99a4eb84ba46e36bf35fc6ee3a769e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a 2D rotation matrix.  <a href="group__transform__hpp.html#ga5e99a4eb84ba46e36bf35fc6ee3a769e">More...</a><br /></td></tr>
<tr class="separator:ga5e99a4eb84ba46e36bf35fc6ee3a769e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6dcd509080e16d23cb28b1b1982c5cc"><td class="memTemplParams" colspan="2">template&lt;typename T , int C = 4, int R = 4&gt; </td></tr>
<tr class="memitem:gab6dcd509080e16d23cb28b1b1982c5cc"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;(C &gt;=3 &amp;&amp;R &gt;=3), mat&lt; decltype(tue::math::sin(std::declval&lt; T &gt;))), C, R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transform__hpp.html#gab6dcd509080e16d23cb28b1b1982c5cc">tue::transform::rotation_mat</a> (const T &amp;axis_x, const T &amp;axis_y, const T &amp;axis_z, const T &amp;angle) noexcept</td></tr>
<tr class="memdesc:gab6dcd509080e16d23cb28b1b1982c5cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a 3D rotation matrix from an axis-angle pair.  <a href="group__transform__hpp.html#gab6dcd509080e16d23cb28b1b1982c5cc">More...</a><br /></td></tr>
<tr class="separator:gab6dcd509080e16d23cb28b1b1982c5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga371fb12a793f8f76cb855b4a50d0b35c"><td class="memTemplParams" colspan="2">template&lt;typename T , int C = 4, int R = 4&gt; </td></tr>
<tr class="memitem:ga371fb12a793f8f76cb855b4a50d0b35c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;(C &gt;=3 &amp;&amp;R &gt;=3), mat&lt; decltype(tue::math::sin(std::declval&lt; T &gt;))), C, R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transform__hpp.html#ga371fb12a793f8f76cb855b4a50d0b35c">tue::transform::rotation_mat</a> (const vec3&lt; T &gt; &amp;axis, const T &amp;angle) noexcept</td></tr>
<tr class="memdesc:ga371fb12a793f8f76cb855b4a50d0b35c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a 3D rotation matrix from an axis-angle pair.  <a href="group__transform__hpp.html#ga371fb12a793f8f76cb855b4a50d0b35c">More...</a><br /></td></tr>
<tr class="separator:ga371fb12a793f8f76cb855b4a50d0b35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafadde95d0e7a53451f71929c7224c997"><td class="memTemplParams" colspan="2">template&lt;typename T , int C = 4, int R = 4&gt; </td></tr>
<tr class="memitem:gafadde95d0e7a53451f71929c7224c997"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;(C &gt;=3 &amp;&amp;R &gt;=3), mat&lt; decltype(tue::math::sin(std::declval&lt; T &gt;))), C, R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transform__hpp.html#gafadde95d0e7a53451f71929c7224c997">tue::transform::rotation_mat</a> (const vec4&lt; T &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:gafadde95d0e7a53451f71929c7224c997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a 3D rotation matrix from an axis-angle vector.  <a href="group__transform__hpp.html#gafadde95d0e7a53451f71929c7224c997">More...</a><br /></td></tr>
<tr class="separator:gafadde95d0e7a53451f71929c7224c997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6c715740ba1c68cc29521a34b613b5f"><td class="memTemplParams" colspan="2">template&lt;typename T , int C = 4, int R = 4&gt; </td></tr>
<tr class="memitem:gaa6c715740ba1c68cc29521a34b613b5f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;(C &gt;=3 &amp;&amp;R &gt;=3), mat&lt; decltype(tue::math::sin(std::declval&lt; T &gt;))), C, R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transform__hpp.html#gaa6c715740ba1c68cc29521a34b613b5f">tue::transform::rotation_mat</a> (const T &amp;x, const T &amp;y, const T &amp;z) noexcept</td></tr>
<tr class="memdesc:gaa6c715740ba1c68cc29521a34b613b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a 3D rotation matrix from a rotation vector.  <a href="group__transform__hpp.html#gaa6c715740ba1c68cc29521a34b613b5f">More...</a><br /></td></tr>
<tr class="separator:gaa6c715740ba1c68cc29521a34b613b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf44b7953459ea4bd08e6d64355b7c372"><td class="memTemplParams" colspan="2">template&lt;typename T , int C = 4, int R = 4&gt; </td></tr>
<tr class="memitem:gaf44b7953459ea4bd08e6d64355b7c372"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;(C &gt;=3 &amp;&amp;R &gt;=3), mat&lt; decltype(tue::math::sin(std::declval&lt; T &gt;))), C, R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transform__hpp.html#gaf44b7953459ea4bd08e6d64355b7c372">tue::transform::rotation_mat</a> (const vec3&lt; T &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:gaf44b7953459ea4bd08e6d64355b7c372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a 3D rotation matrix from a rotation vector.  <a href="group__transform__hpp.html#gaf44b7953459ea4bd08e6d64355b7c372">More...</a><br /></td></tr>
<tr class="separator:gaf44b7953459ea4bd08e6d64355b7c372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fd8d9cc84e7403bb0058a14f6e0ab5c"><td class="memTemplParams" colspan="2">template&lt;typename T , int C = 4, int R = 4&gt; </td></tr>
<tr class="memitem:ga4fd8d9cc84e7403bb0058a14f6e0ab5c"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt;(C &gt;=3 &amp;&amp;R &gt;=3), mat&lt; decltype(tue::math::sin(std::declval&lt; T &gt;))), C, R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transform__hpp.html#ga4fd8d9cc84e7403bb0058a14f6e0ab5c">tue::transform::rotation_mat</a> (const quat&lt; T &gt; &amp;q) noexcept</td></tr>
<tr class="memdesc:ga4fd8d9cc84e7403bb0058a14f6e0ab5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a 3D rotation matrix from a rotation quaternion.  <a href="group__transform__hpp.html#ga4fd8d9cc84e7403bb0058a14f6e0ab5c">More...</a><br /></td></tr>
<tr class="separator:ga4fd8d9cc84e7403bb0058a14f6e0ab5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b2fd845bbebd573cf4a0ab0f6373ab2"><td class="memTemplParams" colspan="2">template&lt;typename T , int C = 4, int R = 4&gt; </td></tr>
<tr class="memitem:ga8b2fd845bbebd573cf4a0ab0f6373ab2"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt;(C &gt;=2 &amp;&amp;R &gt;=2), mat&lt; T, C, R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transform__hpp.html#ga8b2fd845bbebd573cf4a0ab0f6373ab2">tue::transform::scale_mat</a> (const T &amp;x, const T &amp;y) noexcept</td></tr>
<tr class="memdesc:ga8b2fd845bbebd573cf4a0ab0f6373ab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a 2D scale matrix.  <a href="group__transform__hpp.html#ga8b2fd845bbebd573cf4a0ab0f6373ab2">More...</a><br /></td></tr>
<tr class="separator:ga8b2fd845bbebd573cf4a0ab0f6373ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6aa22db1ae8ab35b2f4f7a8de43003c7"><td class="memTemplParams" colspan="2">template&lt;typename T , int C = 4, int R = 4&gt; </td></tr>
<tr class="memitem:ga6aa22db1ae8ab35b2f4f7a8de43003c7"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt;(C &gt;=2 &amp;&amp;R &gt;=2), mat&lt; T, C, R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transform__hpp.html#ga6aa22db1ae8ab35b2f4f7a8de43003c7">tue::transform::scale_mat</a> (const vec2&lt; T &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:ga6aa22db1ae8ab35b2f4f7a8de43003c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a 2D scale matrix.  <a href="group__transform__hpp.html#ga6aa22db1ae8ab35b2f4f7a8de43003c7">More...</a><br /></td></tr>
<tr class="separator:ga6aa22db1ae8ab35b2f4f7a8de43003c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga788b151474429daad9e9e80b687d26c9"><td class="memTemplParams" colspan="2">template&lt;typename T , int C = 4, int R = 4&gt; </td></tr>
<tr class="memitem:ga788b151474429daad9e9e80b687d26c9"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt;(C &gt;=3 &amp;&amp;R &gt;=3), mat&lt; T, C, R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transform__hpp.html#ga788b151474429daad9e9e80b687d26c9">tue::transform::scale_mat</a> (const T &amp;x, const T &amp;y, const T &amp;z) noexcept</td></tr>
<tr class="memdesc:ga788b151474429daad9e9e80b687d26c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a 3D scale matrix.  <a href="group__transform__hpp.html#ga788b151474429daad9e9e80b687d26c9">More...</a><br /></td></tr>
<tr class="separator:ga788b151474429daad9e9e80b687d26c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f9be9a365caad255add2bee1c0c4ded"><td class="memTemplParams" colspan="2">template&lt;typename T , int C = 4, int R = 4&gt; </td></tr>
<tr class="memitem:ga7f9be9a365caad255add2bee1c0c4ded"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt;(C &gt;=3 &amp;&amp;R &gt;=3), mat&lt; T, C, R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transform__hpp.html#ga7f9be9a365caad255add2bee1c0c4ded">tue::transform::scale_mat</a> (const vec3&lt; T &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:ga7f9be9a365caad255add2bee1c0c4ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a 3D scale matrix.  <a href="group__transform__hpp.html#ga7f9be9a365caad255add2bee1c0c4ded">More...</a><br /></td></tr>
<tr class="separator:ga7f9be9a365caad255add2bee1c0c4ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9278e7e108327357cfb32c0a7e7c69c"><td class="memTemplParams" colspan="2">template&lt;typename T , int C = 4, int R = 4&gt; </td></tr>
<tr class="memitem:gaa9278e7e108327357cfb32c0a7e7c69c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;(C &gt;=4 &amp;&amp;R &gt;=4), mat&lt; decltype(tue::math::sin(std::declval&lt; T &gt;))), C, R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transform__hpp.html#gaa9278e7e108327357cfb32c0a7e7c69c">tue::transform::perspective_mat</a> (const T &amp;fovy, const T &amp;aspect, const T &amp;n, const T &amp;f) noexcept</td></tr>
<tr class="memdesc:gaa9278e7e108327357cfb32c0a7e7c69c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a 3D perspective matrix.  <a href="group__transform__hpp.html#gaa9278e7e108327357cfb32c0a7e7c69c">More...</a><br /></td></tr>
<tr class="separator:gaa9278e7e108327357cfb32c0a7e7c69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74f782d480edf58c6ef70e95ed45f4ef"><td class="memTemplParams" colspan="2">template&lt;typename T , int C = 4, int R = 4&gt; </td></tr>
<tr class="memitem:ga74f782d480edf58c6ef70e95ed45f4ef"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt;(C &gt;=3 &amp;&amp;R &gt;=4), mat&lt; decltype(tue::math::recip(std::declval&lt; T &gt;))), C, R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transform__hpp.html#ga74f782d480edf58c6ef70e95ed45f4ef">tue::transform::ortho_mat</a> (const T &amp;width, const T &amp;height, const T &amp;n, const T &amp;f) noexcept</td></tr>
<tr class="memdesc:ga74f782d480edf58c6ef70e95ed45f4ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an orthographic projection matrix.  <a href="group__transform__hpp.html#ga74f782d480edf58c6ef70e95ed45f4ef">More...</a><br /></td></tr>
<tr class="separator:ga74f782d480edf58c6ef70e95ed45f4ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Functions for generating and converting between different types of transformations. </p>
<p>This library has a few different ways of representing 3-dimensional rotations specifically:</p><ul>
<li><b>An axis-angle pair</b><br />
 An axis-angle pair is just as the name implies: it's a rotation around a given axis. It can be represented by three scalars (the axis) and a fourth scalar (the angle) or by a <code>vec3</code> (the axis) and a scalar (the angle). All functions which take an axis-angle pair as their arguments assume the axis is normalized and the angle is measured in radians counter-clockwise around the axis.</li>
<li><b>An axis-angle vector</b><br />
 An axis-angle vector is just an axis-angle pair grouped together into a single <code>vec4</code>. The first three components make up the axis and the fourth component represents the angle.</li>
<li><b>A rotation vector</b><br />
 There are a couple ways to think about a rotation vector. It's represented by three separate scalars or a single <code>vec3</code>. You could imagine it as a more-compact verison of an axis-angle pair: its direction represents the axis of rotation and its magnitude the angle (again, radians counter-clockwise around the axis). You could also imagine it as the composite of three separate rotations with each component representing an angle of rotation around the corresponding principal axis. Rotation vectors are most useful when rotations need to be interpolated and/or multiplied, such as when representing angular velocity.</li>
<li><b>A rotation quaternion</b><br />
 A rotation quaternion is a little more complicated. It's a four-component composite type (a <code>quat</code>). It's kind of like an axis-angle vector, but the entire vector is assumed to be normalized instead of just the axis. This is achieved by multiplying the normalized axis by <code>sin(angle/2)</code> and storing <code>cos(angle/2)</code> instead of the angle itself in the fourth component. Rotation quaternions are best used when representing an orientation in 3-dimensional space or when composing multiple rotations into one. Since they're defined by trigonometric functions, computationally expensive trigonometry isn't needed when using them to rotate vectors or when generating rotation matrices.</li>
<li><b>A rotation matrix</b><br />
 A rotation matrix is just a specific type of transformation matrix that can rotate vectors using matrix multiplication. It's useful for composing with other types of transformation matrices. </li>
</ul>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaaaeee74666e22dae8f8edc57d85b06d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vec4&lt;decltype(tue::math::sin(std::declval&lt;T&gt;)))&gt; tue::transform::axis_angle </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a rotation vector to an axis-angle vector. </p>
<p>If the rotation vector's length is <code>0</code>, returns <code>(0, 0, 1, 0)</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The rotation vector's component type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The rotation vector's first component. </td></tr>
    <tr><td class="paramname">y</td><td>The rotation vector's second component. </td></tr>
    <tr><td class="paramname">z</td><td>The rotation vector's third component.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The axis-angle vector. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4101d9cd158d7bbf2825b35e96af0dc7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vec4&lt;decltype(tue::math::sin(std::declval&lt;T&gt;)))&gt; tue::transform::axis_angle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__vec__hpp.html#ga006798d7302cecb8217a0f94d7e2c5e5">vec3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a rotation vector to an axis-angle vector. </p>
<p>If the rotation vector's length is <code>0</code>, returns <code>(0, 0, 1, 0)</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The rotation vector's component type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The rotation vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The axis-angle vector. </dd></dl>

</div>
</div>
<a class="anchor" id="ga76346bf69314c2738dbec8ff9ad95876"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr vec3&lt;decltype(tue::math::sin(std::declval&lt;T&gt;)))&gt; tue::transform::rotation_vec </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>axis_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>axis_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>axis_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an axis-angle pair to a rotation vector. </p>
<p>This function assumes the axis is normalized.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The axis-angle component type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis_x</td><td>The axis' first component. </td></tr>
    <tr><td class="paramname">axis_y</td><td>The axis' second component. </td></tr>
    <tr><td class="paramname">axis_z</td><td>The axis' third component. </td></tr>
    <tr><td class="paramname">angle</td><td>The angle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rotation vector. </dd></dl>

</div>
</div>
<a class="anchor" id="gacb509e89b7ab371f00dd00fd29c5bbe2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr vec3&lt;decltype(tue::math::sin(std::declval&lt;T&gt;)))&gt; tue::transform::rotation_vec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__vec__hpp.html#ga006798d7302cecb8217a0f94d7e2c5e5">vec3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an axis-angle pair to a rotation vector. </p>
<p>This function assumes the axis is normalized.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The axis-angle component type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td>The axis. </td></tr>
    <tr><td class="paramname">angle</td><td>The angle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rotation vector. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5e66bb337a01361380b7624572981e90"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr vec3&lt;decltype(tue::math::sin(std::declval&lt;T&gt;)))&gt; tue::transform::rotation_vec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__vec__hpp.html#gaed623f4d73b286ac7f9ddb54124f31d8">vec4</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an axis-angle vector to a rotation vector. </p>
<p>This function assumes the axis is normalized. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The axis-angle component type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The axis-angle vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rotation vector. </dd></dl>

</div>
</div>
<a class="anchor" id="ga970795f77a70055a622b13b56c51dfc3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">quat&lt;decltype(tue::math::sin(std::declval&lt;T&gt;)))&gt; tue::transform::rotation_quat </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>axis_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>axis_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>axis_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an axis-angle pair to a rotation quaternion. </p>
<p>This function assumes the axis is normalized.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The axis-angle component type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis_x</td><td>The axis' first component. </td></tr>
    <tr><td class="paramname">axis_y</td><td>The axis' second component. </td></tr>
    <tr><td class="paramname">axis_z</td><td>The axis' third component. </td></tr>
    <tr><td class="paramname">angle</td><td>The angle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rotation quaternion. </dd></dl>

</div>
</div>
<a class="anchor" id="ga53a0ca88778f7e890943f0446b3b0775"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">quat&lt;decltype(tue::math::sin(std::declval&lt;T&gt;)))&gt; tue::transform::rotation_quat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__vec__hpp.html#ga006798d7302cecb8217a0f94d7e2c5e5">vec3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an axis-angle pair to a rotation quaternion. </p>
<p>This function assumes the axis is normalized.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The axis-angle component type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td>The axis. </td></tr>
    <tr><td class="paramname">angle</td><td>The angle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rotation quaternion. </dd></dl>

</div>
</div>
<a class="anchor" id="gaebc4f2ca548da112a66c95900782b34f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">quat&lt;decltype(tue::math::sin(std::declval&lt;T&gt;)))&gt; tue::transform::rotation_quat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__vec__hpp.html#gaed623f4d73b286ac7f9ddb54124f31d8">vec4</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an axis-angle vector to a rotation quaternion. </p>
<p>This function assumes the axis is normalized. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The axis-angle component type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The axis-angle vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rotation quaternion. </dd></dl>

</div>
</div>
<a class="anchor" id="gab7083407cef189d08696f231f10550cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">quat&lt;decltype(tue::math::sin(std::declval&lt;T&gt;)))&gt; tue::transform::rotation_quat </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a rotation vector to a rotation quaternion. </p>
<p>If the rotation vector's length is <code>0</code>, returns <code>(0, 0, 0, 1)</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The rotation vector's component type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The rotation vector's first component. </td></tr>
    <tr><td class="paramname">y</td><td>The rotation vector's second component. </td></tr>
    <tr><td class="paramname">z</td><td>The rotation vector's third component.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rotation quaternion. </dd></dl>

</div>
</div>
<a class="anchor" id="gab6b907a1c8c6b85eb30b52ef4dd39111"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">quat&lt;decltype(tue::math::sin(std::declval&lt;T&gt;)))&gt; tue::transform::rotation_quat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__vec__hpp.html#ga006798d7302cecb8217a0f94d7e2c5e5">vec3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a rotation vector to a rotation quaternion. </p>
<p>If the rotation vector's length is <code>0</code>, returns <code>(0, 0, 0, 1)</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The rotation vector's component type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The rotation vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rotation quaternion. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2d3943ce101ed529e49f3fad0825a899"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C = 4, int R = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt;(C &gt;= 2 &amp;&amp; R &gt;= 3), mat&lt;T, C, R&gt; &gt; tue::transform::translation_mat </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a 2D translation matrix. </p>
<p>The returned matrix might be the transpose of what you expect from other libraries. This library generally prefers compound transformations be written from left-to-right instead of right-to-left.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of parameters <code>x</code> and <code>y</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of the returned matrix. Must be 2, 3, or 4. Defaults to 4. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of the returned matrix. Must be 3 or 4. Defaults to 4.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The translation along the <code>x</code> axis. </td></tr>
    <tr><td class="paramname">y</td><td>The translation along the <code>y</code> axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 2D translation matrix. Values beyond the requested matrix dimensions are truncated.</dd></dl>
<div class="fragment"><div class="line">[              1,               0,  0,  0 ]</div>
<div class="line">[              0,               1,  0,  0 ]</div>
<div class="line">[ R == 3 ? x : 0,  R == 3 ? y : 0,  1,  0 ]</div>
<div class="line">[ R == 4 ? x : 0,  R == 4 ? y : 0,  0,  1 ]</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga32837254e36f0c78faea90d8ef4a7d68"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C = 4, int R = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt;(C &gt;= 2 &amp;&amp; R &gt;= 3), mat&lt;T, C, R&gt; &gt; tue::transform::translation_mat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__vec__hpp.html#ga229a7e831fb40db6ef9972b4598e015d">vec2</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a 2D translation matrix. </p>
<p>The returned matrix might be the transpose of what you expect from other libraries. This library generally prefers compound transformations be written from left-to-right instead of right-to-left.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>v</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of the returned matrix. Must be 2, 3, or 4. Defaults to 4. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of the returned matrix. Must be 3 or 4. Defaults to 4.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The translation vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 2D translation matrix. Values beyond the requested matrix dimensions are truncated.</dd></dl>
<div class="fragment"><div class="line">[                 1,                  0,  0,  0 ]</div>
<div class="line">[                 0,                  1,  0,  0 ]</div>
<div class="line">[ R == 3 ? v[0] : 0,  R == 3 ? v[1] : 0,  1,  0 ]</div>
<div class="line">[ R == 4 ? v[0] : 0,  R == 4 ? v[1] : 0,  0,  1 ]</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gaa7e7e1fa5d789fd2614b0d97723cdd98"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C = 4, int R = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt;(C &gt;= 3 &amp;&amp; R &gt;= 4), mat&lt;T, C, R&gt; &gt; tue::transform::translation_mat </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a 3D translation matrix. </p>
<p>The returned matrix might be the transpose of what you expect from other libraries. This library generally prefers compound transformations be written from left-to-right instead of right-to-left.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of parameters <code>x</code>, <code>y</code>, and <code>z</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of the returned matrix. Must be 3 or 4. Defaults to 4. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of the returned matrix. Must be 4. Defaults to 4.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The translation along the <code>x</code> axis. </td></tr>
    <tr><td class="paramname">y</td><td>The translation along the <code>y</code> axis. </td></tr>
    <tr><td class="paramname">z</td><td>The translation along the <code>z</code> axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 3D translation matrix. Values beyond the requested matrix dimensions are truncated.</dd></dl>
<div class="fragment"><div class="line">[ 1,  0,  0,  0 ]</div>
<div class="line">[ 0,  1,  0,  0 ]</div>
<div class="line">[ 0,  0,  1,  0 ]</div>
<div class="line">[ x,  y,  z,  1 ]</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga8213130d102ec03b76e4981a0410fc45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C = 4, int R = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt;(C &gt;= 3 &amp;&amp; R &gt;= 4), mat&lt;T, C, R&gt; &gt; tue::transform::translation_mat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__vec__hpp.html#ga006798d7302cecb8217a0f94d7e2c5e5">vec3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a 3D translation matrix. </p>
<p>The returned matrix might be the transpose of what you expect from other libraries. This library generally prefers compound transformations be written from left-to-right instead of right-to-left.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>v</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of the returned matrix. Must be 3 or 4. Defaults to 4. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of the returned matrix. Must be 4. Defaults to 4.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The translation vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 3D translation matrix. Values beyond the requested matrix dimensions are truncated.</dd></dl>
<div class="fragment"><div class="line">[   1 ,    0 ,    0 ,  0 ]</div>
<div class="line">[   0 ,    1 ,    0 ,  0 ]</div>
<div class="line">[   0 ,    0 ,    1 ,  0 ]</div>
<div class="line">[ v[0],  v[1],  v[2],  1 ]</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga5e99a4eb84ba46e36bf35fc6ee3a769e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C = 4, int R = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;(C &gt;= 2 &amp;&amp; R &gt;= 2), mat&lt;decltype(tue::math::sin(std::declval&lt;T&gt;))), C, R&gt; &gt; tue::transform::rotation_mat </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>angle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a 2D rotation matrix. </p>
<p>The returned matrix might be the transpose of what you expect from other libraries. This library generally prefers compound transformations be written from left-to-right instead of right-to-left.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of parameter <code>angle</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of the returned matrix. Must be 2, 3, or 4. Defaults to 4. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of the returned matrix. Must be 2, 3, or 4. Defaults to 4.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>The rotation (measured in radians counter-clockwise).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 2D rotation matrix. Values beyond the requested matrix dimensions are truncated.</dd></dl>
<div class="fragment"><div class="line">[  <a class="code" href="group__mat__hpp.html#ga58ca317305f155313cbab62f1cab8ddd">cos</a>(angle),  <a class="code" href="group__mat__hpp.html#ga5f6ae28ba3a684c889d97135251a2a8d">sin</a>(angle),  0,  0 ]</div>
<div class="line">[ -<a class="code" href="group__mat__hpp.html#ga5f6ae28ba3a684c889d97135251a2a8d">sin</a>(angle),  <a class="code" href="group__mat__hpp.html#ga58ca317305f155313cbab62f1cab8ddd">cos</a>(angle),  0,  0 ]</div>
<div class="line">[           0,           0,  1,  0 ]</div>
<div class="line">[           0,           0,  0,  1 ]</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gab6dcd509080e16d23cb28b1b1982c5cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C = 4, int R = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;(C &gt;= 3 &amp;&amp; R &gt;= 3), mat&lt;decltype(tue::math::sin(std::declval&lt;T&gt;))), C, R&gt; &gt; tue::transform::rotation_mat </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>axis_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>axis_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>axis_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a 3D rotation matrix from an axis-angle pair. </p>
<p>This function assumes the axis is normalized. <br />
 The returned matrix might be the transpose of what you expect from other libraries. This library generally prefers compound transformations be written from left-to-right instead of right-to-left.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The axis-angle component type. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of the returned matrix. Must be 3 or 4. Defaults to 4. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of the returned matrix. Must be 3 or 4. Defaults to 4.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis_x</td><td>The axis' first component. </td></tr>
    <tr><td class="paramname">axis_y</td><td>The axis' second component. </td></tr>
    <tr><td class="paramname">axis_z</td><td>The axis' third component. </td></tr>
    <tr><td class="paramname">angle</td><td>The angle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 3D rotation matrix. Values beyond the requested matrix dimensions are truncated.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Where x, y, and z make the axis of rotation</span></div>
<div class="line"><span class="comment">// and s and c are sin(angle) and cos(angle).</span></div>
<div class="line"></div>
<div class="line">[ xx(1-c) +  c,  xy(1-c) + zs,  xz(1-c) - ys,  0 ]</div>
<div class="line">[ xy(1-c) - zs,  yy(1-c) +  c,  yz(1-c) - xs,  0 ]</div>
<div class="line">[ xz(1-c) + ys,  yz(1-c) - xs,  zz(1-c) +  c,  0 ]</div>
<div class="line">[            0,             0,             0,  1 ]</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga371fb12a793f8f76cb855b4a50d0b35c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C = 4, int R = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;(C &gt;= 3 &amp;&amp; R &gt;= 3), mat&lt;decltype(tue::math::sin(std::declval&lt;T&gt;))), C, R&gt; &gt; tue::transform::rotation_mat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__vec__hpp.html#ga006798d7302cecb8217a0f94d7e2c5e5">vec3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a 3D rotation matrix from an axis-angle pair. </p>
<p>This function assumes the axis is normalized. <br />
 The returned matrix might be the transpose of what you expect from other libraries. This library generally prefers compound transformations be written from left-to-right instead of right-to-left.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The axis-angle component type. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of the returned matrix. Must be 3 or 4. Defaults to 4. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of the returned matrix. Must be 3 or 4. Defaults to 4.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td>The axis. </td></tr>
    <tr><td class="paramname">angle</td><td>The angle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 3D rotation matrix. Values beyond the requested matrix dimensions are truncated.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Where x, y, and z make the axis of rotation</span></div>
<div class="line"><span class="comment">// and s and c are sin(angle) and cos(angle).</span></div>
<div class="line"></div>
<div class="line">[ xx(1-c) +  c,  xy(1-c) + zs,  xz(1-c) - ys,  0 ]</div>
<div class="line">[ xy(1-c) - zs,  yy(1-c) +  c,  yz(1-c) - xs,  0 ]</div>
<div class="line">[ xz(1-c) + ys,  yz(1-c) - xs,  zz(1-c) +  c,  0 ]</div>
<div class="line">[            0,             0,             0,  1 ]</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gafadde95d0e7a53451f71929c7224c997"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C = 4, int R = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;(C &gt;= 3 &amp;&amp; R &gt;= 3), mat&lt;decltype(tue::math::sin(std::declval&lt;T&gt;))), C, R&gt; &gt; tue::transform::rotation_mat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__vec__hpp.html#gaed623f4d73b286ac7f9ddb54124f31d8">vec4</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a 3D rotation matrix from an axis-angle vector. </p>
<p>This function assumes the axis is normalized. <br />
 The returned matrix might be the transpose of what you expect from other libraries. This library generally prefers compound transformations be written from left-to-right instead of right-to-left.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The axis-angle component type. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of the returned matrix. Must be 3 or 4. Defaults to 4. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of the returned matrix. Must be 3 or 4. Defaults to 4.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The axis-angle vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 3D rotation matrix. Values beyond the requested matrix dimensions are truncated.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Where x, y, and z make the axis of rotation</span></div>
<div class="line"><span class="comment">// and s and c are sin(v[3]) and cos(v[3]).</span></div>
<div class="line"></div>
<div class="line">[ xx(1-c) +  c,  xy(1-c) + zs,  xz(1-c) - ys,  0 ]</div>
<div class="line">[ xy(1-c) - zs,  yy(1-c) +  c,  yz(1-c) - xs,  0 ]</div>
<div class="line">[ xz(1-c) + ys,  yz(1-c) - xs,  zz(1-c) +  c,  0 ]</div>
<div class="line">[            0,             0,             0,  1 ]</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gaa6c715740ba1c68cc29521a34b613b5f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C = 4, int R = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;(C &gt;= 3 &amp;&amp; R &gt;= 3), mat&lt;decltype(tue::math::sin(std::declval&lt;T&gt;))), C, R&gt; &gt; tue::transform::rotation_mat </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a 3D rotation matrix from a rotation vector. </p>
<p>The returned matrix might be the transpose of what you expect from other libraries. This library generally prefers compound transformations be written from left-to-right instead of right-to-left.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The rotation vector's component type. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of the returned matrix. Must be 3 or 4. Defaults to 4. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of the returned matrix. Must be 3 or 4. Defaults to 4.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The rotation vector's first component. </td></tr>
    <tr><td class="paramname">y</td><td>The rotation vector's second component. </td></tr>
    <tr><td class="paramname">z</td><td>The rotation vector's third component.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 3D rotation matrix.</dd></dl>
<div class="fragment"><div class="line"><span class="keywordflow">return</span> tue::transform::rotation_mat&lt;T, C, R&gt;(</div>
<div class="line">    <a class="code" href="group__transform__hpp.html#gaaaeee74666e22dae8f8edc57d85b06d1">tue::transform::axis_angle</a>(x, y, z));</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gaf44b7953459ea4bd08e6d64355b7c372"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C = 4, int R = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;(C &gt;= 3 &amp;&amp; R &gt;= 3), mat&lt;decltype(tue::math::sin(std::declval&lt;T&gt;))), C, R&gt; &gt; tue::transform::rotation_mat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__vec__hpp.html#ga006798d7302cecb8217a0f94d7e2c5e5">vec3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a 3D rotation matrix from a rotation vector. </p>
<p>The returned matrix might be the transpose of what you expect from other libraries. This library generally prefers compound transformations be written from left-to-right instead of right-to-left.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The rotation vector's component type. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of the returned matrix. Must be 3 or 4. Defaults to 4. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of the returned matrix. Must be 3 or 4. Defaults to 4.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The rotation vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 3D rotation matrix.</dd></dl>
<div class="fragment"><div class="line"><span class="keywordflow">return</span> tue::transform::rotation_mat&lt;T, C, R&gt;(</div>
<div class="line">    <a class="code" href="group__transform__hpp.html#gaaaeee74666e22dae8f8edc57d85b06d1">tue::transform::axis_angle</a>(v));</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga4fd8d9cc84e7403bb0058a14f6e0ab5c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C = 4, int R = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt;(C &gt;= 3 &amp;&amp; R &gt;= 3), mat&lt;decltype(tue::math::sin(std::declval&lt;T&gt;))), C, R&gt; &gt; tue::transform::rotation_mat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__quat__hpp.html#classtue_1_1quat">quat</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a 3D rotation matrix from a rotation quaternion. </p>
<p>This function assumes the quaternion is normalized. <br />
 The returned matrix might be the transpose of what you expect from other libraries. This library generally prefers compound transformations be written from left-to-right instead of right-to-left.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The rotation quaternion's component type. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of the returned matrix. Must be 3 or 4. Defaults to 4. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of the returned matrix. Must be 3 or 4. Defaults to 4.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The rotation quaternion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 3D rotation matrix. Values beyond the requested matrix dimensions are truncated.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Where x, y, z, and w are the components of the rotation</span></div>
<div class="line"><span class="comment">// quaternion.</span></div>
<div class="line"></div>
<div class="line">[ 1 - 2yy - 2zz,      2xy + 2zw,      2xz - 2yw,  0 ]</div>
<div class="line">[     2xy - 2zw,  1 - 2xx - 2zz,      2yz + 2xw,  0 ]</div>
<div class="line">[     2xz + 2yw,      2yz - 2xw,  1 - 2xx - 2yy,  0 ]</div>
<div class="line">[             0,              0,              0,  1 ]</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga8b2fd845bbebd573cf4a0ab0f6373ab2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C = 4, int R = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt;(C &gt;= 2 &amp;&amp; R &gt;= 2), mat&lt;T, C, R&gt; &gt; tue::transform::scale_mat </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a 2D scale matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of parameters <code>x</code> and <code>y</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of the returned matrix. Must be 2, 3, or 4. Defaults to 4. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of the returned matrix. Must be 2, 3, or 4. Defaults to 4.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The scale along the <code>x</code> axis. </td></tr>
    <tr><td class="paramname">y</td><td>The scale along the <code>y</code> axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 2D scale matrix. Values beyond the requested matrix dimensions are truncated.</dd></dl>
<div class="fragment"><div class="line">[ x,  0,  0,  0 ]</div>
<div class="line">[ 0,  y,  0,  0 ]</div>
<div class="line">[ 0,  0,  1,  0 ]</div>
<div class="line">[ 0,  0,  0,  1 ]</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga6aa22db1ae8ab35b2f4f7a8de43003c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C = 4, int R = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt;(C &gt;= 2 &amp;&amp; R &gt;= 2), mat&lt;T, C, R&gt; &gt; tue::transform::scale_mat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__vec__hpp.html#ga229a7e831fb40db6ef9972b4598e015d">vec2</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a 2D scale matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>v</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of the returned matrix. Must be 2, 3, or 4. Defaults to 4. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of the returned matrix. Must be 2, 3, or 4. Defaults to 4.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The scale vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 2D scale matrix. Values beyond the requested matrix dimensions are truncated.</dd></dl>
<div class="fragment"><div class="line">[ v[0],    0 ,  0,  0 ]</div>
<div class="line">[   0 ,  v[1],  0,  0 ]</div>
<div class="line">[   0 ,    0 ,  1,  0 ]</div>
<div class="line">[   0 ,    0 ,  0,  1 ]</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga788b151474429daad9e9e80b687d26c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C = 4, int R = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt;(C &gt;= 3 &amp;&amp; R &gt;= 3), mat&lt;T, C, R&gt; &gt; tue::transform::scale_mat </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a 3D scale matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of parameters <code>x</code>, <code>y</code>, and <code>z</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of the returned matrix. Must be 3 or 4. Defaults to 4. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of the returned matrix. Must be 3 or 4. Defaults to 4.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The scale along the <code>x</code> axis. </td></tr>
    <tr><td class="paramname">y</td><td>The scale along the <code>y</code> axis. </td></tr>
    <tr><td class="paramname">z</td><td>The scale along the <code>z</code> axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 3D scale matrix. Values beyond the requested matrix dimensions are truncated.</dd></dl>
<div class="fragment"><div class="line">[ x,  0,  0,  0 ]</div>
<div class="line">[ 0,  y,  0,  0 ]</div>
<div class="line">[ 0,  0,  z,  0 ]</div>
<div class="line">[ 0,  0,  0,  1 ]</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga7f9be9a365caad255add2bee1c0c4ded"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C = 4, int R = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt;(C &gt;= 3 &amp;&amp; R &gt;= 3), mat&lt;T, C, R&gt; &gt; tue::transform::scale_mat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__vec__hpp.html#ga006798d7302cecb8217a0f94d7e2c5e5">vec3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a 3D scale matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type of <code>v</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of the returned matrix. Must be 3 or 4. Defaults to 4. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of the returned matrix. Must be 3 or 4. Defaults to 4.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The scale vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 3D scale matrix. Values beyond the requested matrix dimensions are truncated.</dd></dl>
<div class="fragment"><div class="line">[ v[0],    0 ,    0 ,  0 ]</div>
<div class="line">[   0 ,  v[1],    0 ,  0 ]</div>
<div class="line">[   0 ,    0 ,  v[2],  0 ]</div>
<div class="line">[   0 ,    0 ,    0 ,  1 ]</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gaa9278e7e108327357cfb32c0a7e7c69c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C = 4, int R = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;(C &gt;= 4 &amp;&amp; R &gt;= 4), mat&lt;decltype(tue::math::sin(std::declval&lt;T&gt;))), C, R&gt; &gt; tue::transform::perspective_mat </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>fovy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>aspect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a 3D perspective matrix. </p>
<p>The returned matrix might be the transpose of what you expect from other libraries. This library generally prefers compound transformations be written from left-to-right instead of right-to-left.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of all four parameters. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of the returned matrix. Must be 4. Defaults to 4. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of the returned matrix. Must be 4. Defaults to 4.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fovy</td><td>The vertical field of view (measured in radians). </td></tr>
    <tr><td class="paramname">aspect</td><td>The aspect ratio (width / height). </td></tr>
    <tr><td class="paramname">n</td><td>The distance to the near view plane. </td></tr>
    <tr><td class="paramname">f</td><td>The distance to the far view plane.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 3D perspective matrix.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Where s and c are sin(fovy/2) and cos(fovy/2)</span></div>
<div class="line"></div>
<div class="line">[ c/s/aspect,    0,            0,   0 ]</div>
<div class="line">[          0,  c/s,            0,   0 ]</div>
<div class="line">[          0,    0,  (n+f)/(n-f),  -1 ]</div>
<div class="line">[          0,    0,  (2nf)/(n-f),   0 ]</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga74f782d480edf58c6ef70e95ed45f4ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int C = 4, int R = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt;(C &gt;= 3 &amp;&amp; R &gt;= 4), mat&lt;decltype(tue::math::recip(std::declval&lt;T&gt;))), C, R&gt; &gt; tue::transform::ortho_mat </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an orthographic projection matrix. </p>
<p>The returned matrix might be the transpose of what you expect from other libraries. This library generally prefers compound transformations be written from left-to-right instead of right-to-left.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of all four parameters. </td></tr>
    <tr><td class="paramname">C</td><td>The column count of the returned matrix. Must be 3 or 4. Defaults to 4. </td></tr>
    <tr><td class="paramname">R</td><td>The row count of the returned matrix. Must be 4. Defaults to 4.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The orthographic projection width. </td></tr>
    <tr><td class="paramname">height</td><td>The orthographic projection height. </td></tr>
    <tr><td class="paramname">n</td><td>The distance to the near view plane. </td></tr>
    <tr><td class="paramname">f</td><td>The distance to the far view plane.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An orthographic projection matrix.</dd></dl>
<div class="fragment"><div class="line">[ 2/width,         0,            0,  0 ]</div>
<div class="line">[       0,  2/height,            0,  0 ]</div>
<div class="line">[       0,         0,    (2)/(n-f),  0 ]</div>
<div class="line">[       0,         0,  (n+f)/(n-f),  1 ]</div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
